{
  "code": "\r\n\r\n'''\r\n\r\nclass Node:\r\n    def __init__(self, d):\r\n        self.data=d\r\n        self.next=None\r\n        self.bottom=None\r\n        \r\n'''\r\nclass Solution():\r\n    def merge(self, first, second):\r\n        if not first:\r\n            return second\r\n        if not second:\r\n            return first\r\n    \r\n        result = None\r\n        if first.data < second.data:\r\n            result = first\r\n            result.bottom = self.merge(first.bottom, second)\r\n        else:\r\n            result = second\r\n            result.bottom = self.merge(first, second.bottom)\r\n    \r\n        return result\r\n    def flatten(self, head):\r\n        #Your code here\r\n        if not head or not head.next:\r\n            return head\r\n    \r\n        # Recursively flatten the next sublist\r\n        head.next = self.flatten(head.next)\r\n    \r\n        # Merge the current sublist with the flattened next sublist\r\n        head = self.merge(head, head.next)\r\n    \r\n        return head\r\n        \r\n    \r\n        \r\n\r\n\r\n#{ \r\n # Driver Code Starts\r\n#Initial Template for Python 3\r\n\r\nclass Node:\r\n    def __init__(self, d):\r\n        self.data=d\r\n        self.next=None\r\n        self.bottom=None\r\n        \r\n        \r\n\r\ndef printList(node):\r\n    while(node is not None):\r\n        print(node.data,end=\" \")\r\n        node=node.bottom\r\n        \r\n    print()\r\n\r\n\r\nif __name__==\"__main__\":\r\n    t=int(input())\r\n    while(t>0):\r\n        head=None\r\n        N=int(input())\r\n        arr=[]\r\n        \r\n        arr=[int(x) for x in input().strip().split()]\r\n        temp=None\r\n        tempB=None\r\n        pre=None\r\n        preB=None\r\n        \r\n        flag=1\r\n        flag1=1\r\n        listo=[int(x) for x in input().strip().split()]\r\n        it=0\r\n        for i in range(N):\r\n            m=arr[i]\r\n            m-=1\r\n            a1=listo[it]\r\n            it+=1\r\n            temp=Node(a1)\r\n            if flag is 1:\r\n                head=temp\r\n                pre=temp\r\n                flag=0\r\n                flag1=1\r\n            else:\r\n                pre.next=temp\r\n                pre=temp\r\n                flag1=1\r\n                \r\n            for j in range(m):\r\n                a=listo[it]\r\n                it+=1\r\n                tempB=Node(a)\r\n                if flag1 is 1:\r\n                    temp.bottom=tempB\r\n                    preB=tempB\r\n                    flag1=0\r\n                else:\r\n                    preB.bottom=tempB\r\n                    preB=tempB\r\n        obj=Solution()\r\n        root=obj.flatten(head)\r\n        printList(root)\r\n        \r\n        t-=1\r\n            \r\n# } Driver Code Ends",
  "status": "1",
  "language": "python3",
  "user_code": "#User function Template for python3\r\n\r\n\r\n'''\r\n\r\nclass Node:\r\n    def __init__(self, d):\r\n        self.data=d\r\n        self.next=None\r\n        self.bottom=None\r\n        \r\n'''\r\nclass Solution():\r\n    def merge(self, first, second):\r\n        if not first:\r\n            return second\r\n        if not second:\r\n            return first\r\n    \r\n        result = None\r\n        if first.data < second.data:\r\n            result = first\r\n            result.bottom = self.merge(first.bottom, second)\r\n        else:\r\n            result = second\r\n            result.bottom = self.merge(first, second.bottom)\r\n    \r\n        return result\r\n    def flatten(self, head):\r\n        #Your code here\r\n        if not head or not head.next:\r\n            return head\r\n    \r\n        # Recursively flatten the next sublist\r\n        head.next = self.flatten(head.next)\r\n    \r\n        # Merge the current sublist with the flattened next sublist\r\n        head = self.merge(head, head.next)\r\n    \r\n        return head\r\n        \r\n    \r\n        \r\n\r\n\r\n"
}