{
  "code": "//\r\n\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\nstruct Node\r\n{\r\n\tint data;\r\n\tstruct Node *left;\r\n\tstruct Node *right;\r\n\t\r\n\tNode(int x){\r\n\t    data = x;\r\n\t    left = NULL;\r\n\t    right = NULL;\r\n\t}\r\n};\r\n\r\n\r\nvoid printPostOrder(Node *root)\r\n{\r\n\tif(root==NULL)\r\n\t\treturn;\r\n\tprintPostOrder(root->left);\r\n\tprintPostOrder(root->right);\r\n\tcout<<root->data<<\" \";\r\n}\r\n\r\n// } Driver Code Ends\r\n\r\n/*Complete the code here.\r\nNode is as follows:\r\nstruct Node\r\n{\r\n  int data;\r\n  Node* left;\r\n  Node* right;\r\n};\r\n*/\r\nclass Solution{\r\n    public:\r\n    Node* buildTree(int in[],int pre[], int n)\r\n    {\r\n        // Code here\r\n        unordered_map<int,int> index;\r\n        // for(int i=0;i<n;i++)\r\n        //     index[in[i]] = i;\r\n        return makeTree(in,0,n-1,pre,0,n-1,index);\r\n    }\r\n    Node* makeTree(int inoder[], int startIn, int endIn, int preorder[], int startPre, int endPre, unordered_map<int,int> index){\r\n        if(startIn > endIn || startPre > endPre)\r\n            return NULL;\r\n        Node *root = new Node(preorder[startPre]);\r\n        int indexIn = findIndex(inoder, preorder[startPre], startIn, endIn);\r\n        int element = indexIn - startIn;\r\n        root->left = makeTree(inoder, startIn, indexIn-1, preorder, startPre + 1, startPre + element, index);\r\n        root->right = makeTree(inoder,indexIn+1,endIn,preorder,startPre + element+1,endPre,index);\r\n        return root;\r\n    }\r\n    int findIndex(int inOrder[], int key, int start, int end){\r\n        for (int i = start; i <= end; i++)\r\n        {\r\n            if(inOrder[i] == key)\r\n                return i;\r\n        }\r\n        \r\n    }\r\n};\r\n\r\n//{ Driver Code Starts.\r\nint main()\r\n{\r\n\tint t;\r\n\tcin>>t;\r\n\twhile(t--)\r\n\t{\r\n\t\tint n;\r\n\t\tcin>>n;\r\n\t\t\r\n\t\tint inorder[n], preorder[n];\r\n\t\tfor(int i=0; i<n; i++)\r\n\t\t\tcin>> inorder[i];\r\n\t\tfor(int i=0; i<n; i++)\r\n\t\t\tcin>> preorder[i];\r\n\t\tSolution obj;\r\n\t\tNode *root = obj.buildTree(inorder, preorder, n);\r\n\t\tprintPostOrder(root);\r\n\t\tcout<< endl;\r\n\t}\r\n}\r\n\r\n// } Driver Code Ends",
  "status": "1",
  "language": "cpp",
  "user_code": "\r\n/*Complete the code here.\r\nNode is as follows:\r\nstruct Node\r\n{\r\n  int data;\r\n  Node* left;\r\n  Node* right;\r\n};\r\n*/\r\nclass Solution{\r\n    public:\r\n    Node* buildTree(int in[],int pre[], int n)\r\n    {\r\n        // Code here\r\n        unordered_map<int,int> index;\r\n        // for(int i=0;i<n;i++)\r\n        //     index[in[i]] = i;\r\n        return makeTree(in,0,n-1,pre,0,n-1,index);\r\n    }\r\n    Node* makeTree(int inoder[], int startIn, int endIn, int preorder[], int startPre, int endPre, unordered_map<int,int> index){\r\n        if(startIn > endIn || startPre > endPre)\r\n            return NULL;\r\n        Node *root = new Node(preorder[startPre]);\r\n        int indexIn = findIndex(inoder, preorder[startPre], startIn, endIn);\r\n        int element = indexIn - startIn;\r\n        root->left = makeTree(inoder, startIn, indexIn-1, preorder, startPre + 1, startPre + element, index);\r\n        root->right = makeTree(inoder,indexIn+1,endIn,preorder,startPre + element+1,endPre,index);\r\n        return root;\r\n    }\r\n    int findIndex(int inOrder[], int key, int start, int end){\r\n        for (int i = start; i <= end; i++)\r\n        {\r\n            if(inOrder[i] == key)\r\n                return i;\r\n        }\r\n        \r\n    }\r\n};\r\n"
}