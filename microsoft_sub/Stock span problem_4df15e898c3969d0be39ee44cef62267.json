{
  "code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\n\r\n// } Driver Code Ends\r\n\r\n\r\nclass Solution\r\n{\r\n    public:\r\n    //Function to calculate the span of stock\u00e2\u20ac\u2122s price for all n days.\r\n    \r\n     vector<int> calculateSpan(int price[], int n) {\r\n        vector<int> span(n, 1); // Initialize all spans to 1\r\n        stack<int> st; // Stack to store indices of previous greater elements\r\n        \r\n        // Process each day's price\r\n        for (int i = 0; i < n; i++) {\r\n            // Pop elements from the stack while the current price is greater than or equal to the price corresponding to the index at the top of the stack\r\n            while (!st.empty() && price[i] >= price[st.top()])\r\n                st.pop();\r\n            \r\n            // If the stack is empty, the span of the current day is i+1\r\n            // Otherwise, it is the difference between the current day and the index at the top of the stack\r\n            span[i] = (st.empty()) ? (i + 1) : (i - st.top());\r\n            \r\n            // Push the current index onto the stack\r\n            st.push(i);\r\n        }\r\n        \r\n        return span;}\r\n        \r\n};\r\n\r\n\r\n\r\n//{ Driver Code Starts.\r\n\r\nint main()\r\n{\r\n\tint t;\r\n\tcin>>t;\r\n\twhile(t--)\r\n\t{\r\n\t\tint n;\r\n\t\tcin>>n;\r\n\t\tint i,a[n];\r\n\t\tfor(i=0;i<n;i++)\r\n\t\t{\r\n\t\t\tcin>>a[i];\r\n\t\t}\r\n\t\tSolution obj;\r\n\t\tvector <int> s = obj.calculateSpan(a, n);\r\n\t\t\r\n\t\tfor(i=0;i<n;i++)\r\n\t\t{\r\n\t\t\tcout<<s[i]<<\" \";\r\n\t\t}\r\n\t\tcout<<endl;\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\n// } Driver Code Ends",
  "status": "1",
  "language": "cpp",
  "user_code": "\r\n\r\nclass Solution\r\n{\r\n    public:\r\n    //Function to calculate the span of stock\u00e2\u20ac\u2122s price for all n days.\r\n    \r\n     vector<int> calculateSpan(int price[], int n) {\r\n        vector<int> span(n, 1); // Initialize all spans to 1\r\n        stack<int> st; // Stack to store indices of previous greater elements\r\n        \r\n        // Process each day's price\r\n        for (int i = 0; i < n; i++) {\r\n            // Pop elements from the stack while the current price is greater than or equal to the price corresponding to the index at the top of the stack\r\n            while (!st.empty() && price[i] >= price[st.top()])\r\n                st.pop();\r\n            \r\n            // If the stack is empty, the span of the current day is i+1\r\n            // Otherwise, it is the difference between the current day and the index at the top of the stack\r\n            span[i] = (st.empty()) ? (i + 1) : (i - st.top());\r\n            \r\n            // Push the current index onto the stack\r\n            st.push(i);\r\n        }\r\n        \r\n        return span;}\r\n        \r\n};\r\n\r\n\r\n"
}