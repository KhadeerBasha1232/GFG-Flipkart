{
  "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n// } Driver Code Ends\r\nclass Solution {\r\n  public:\r\n    // Function to detect cycle in an undirected graph.\r\n    \r\n    int parent[100005];\r\n    int group_size[100005];\r\n    \r\n    void dsu_initialize(int n)\r\n    {\r\n        for(int i=0; i<n; i++)\r\n        {\r\n            parent[i] = i;\r\n            group_size[i] = 1;\r\n        }\r\n    }\r\n    int dsu_find(int node)\r\n    {\r\n        if(parent[node] == node)\r\n        {\r\n            return node;\r\n        }\r\n        int leader = dsu_find(parent[node]);\r\n        parent[node] = leader;\r\n        return leader;\r\n    }\r\n    void union_by_size(int node1, int node2)\r\n    {\r\n        int leaderA = dsu_find(node1);\r\n        int leaderB = dsu_find(node2);\r\n        \r\n        if(group_size[leaderA] > group_size[leaderB])\r\n        {\r\n            parent[leaderB] = leaderA;\r\n            group_size[leaderA] += group_size[leaderB];\r\n        }\r\n        else\r\n        {\r\n            parent[leaderA] = leaderB;\r\n            group_size[leaderB] += group_size[leaderA];\r\n        }\r\n    }\r\n    bool isCycle(int V, vector<int> adj[]) {\r\n        // Code here\r\n        dsu_initialize(V);\r\n        for(int i=0; i<V; i++)\r\n        {\r\n            sort(adj[i].begin(),adj[i].end());\r\n            \r\n            for(int child : adj[i])\r\n            {\r\n                int leaderA = dsu_find(i);\r\n                int leaderB = dsu_find(child);\r\n                \r\n                if(leaderA == leaderB)\r\n                {\r\n                    return true;\r\n                }\r\n                else\r\n                {\r\n                    union_by_size(i, child);\r\n                }\r\n                sort(adj[child].begin(),adj[child].end(),greater<int>());\r\n                \r\n                if(adj[child].back() == i)\r\n                {\r\n                    adj[child].pop_back();\r\n                }\r\n                \r\n            }\r\n        }\r\n        return false;\r\n    }\r\n};\r\n\r\n//{ Driver Code Starts.\r\nint main() {\r\n    int tc;\r\n    cin >> tc;\r\n    while (tc--) {\r\n        int V, E;\r\n        cin >> V >> E;\r\n        vector<int> adj[V];\r\n        for (int i = 0; i < E; i++) {\r\n            int u, v;\r\n            cin >> u >> v;\r\n            adj[u].push_back(v);\r\n            adj[v].push_back(u);\r\n        }\r\n        Solution obj;\r\n        bool ans = obj.isCycle(V, adj);\r\n        if (ans)\r\n            cout << \"1\\n\";\r\n        else\r\n            cout << \"0\\n\";\r\n    }\r\n    return 0;\r\n}\r\n// } Driver Code Ends",
  "status": "1",
  "language": "cpp",
  "user_code": "class Solution {\r\n  public:\r\n    // Function to detect cycle in an undirected graph.\r\n    \r\n    int parent[100005];\r\n    int group_size[100005];\r\n    \r\n    void dsu_initialize(int n)\r\n    {\r\n        for(int i=0; i<n; i++)\r\n        {\r\n            parent[i] = i;\r\n            group_size[i] = 1;\r\n        }\r\n    }\r\n    int dsu_find(int node)\r\n    {\r\n        if(parent[node] == node)\r\n        {\r\n            return node;\r\n        }\r\n        int leader = dsu_find(parent[node]);\r\n        parent[node] = leader;\r\n        return leader;\r\n    }\r\n    void union_by_size(int node1, int node2)\r\n    {\r\n        int leaderA = dsu_find(node1);\r\n        int leaderB = dsu_find(node2);\r\n        \r\n        if(group_size[leaderA] > group_size[leaderB])\r\n        {\r\n            parent[leaderB] = leaderA;\r\n            group_size[leaderA] += group_size[leaderB];\r\n        }\r\n        else\r\n        {\r\n            parent[leaderA] = leaderB;\r\n            group_size[leaderB] += group_size[leaderA];\r\n        }\r\n    }\r\n    bool isCycle(int V, vector<int> adj[]) {\r\n        // Code here\r\n        dsu_initialize(V);\r\n        for(int i=0; i<V; i++)\r\n        {\r\n            sort(adj[i].begin(),adj[i].end());\r\n            \r\n            for(int child : adj[i])\r\n            {\r\n                int leaderA = dsu_find(i);\r\n                int leaderB = dsu_find(child);\r\n                \r\n                if(leaderA == leaderB)\r\n                {\r\n                    return true;\r\n                }\r\n                else\r\n                {\r\n                    union_by_size(i, child);\r\n                }\r\n                sort(adj[child].begin(),adj[child].end(),greater<int>());\r\n                \r\n                if(adj[child].back() == i)\r\n                {\r\n                    adj[child].pop_back();\r\n                }\r\n                \r\n            }\r\n        }\r\n        return false;\r\n    }\r\n};\r\n"
}