{
  "code": "\r\nclass Solution:\r\n    def permuteUnique(self, nums):\r\n        nums.sort()  # Sort the input array to handle duplicates\r\n        result = []\r\n        used = [False] * len(nums)\r\n        self.backtrack(nums, used, [], result)\r\n        return result\r\n    \r\n    def backtrack(self, nums, used, current, result):\r\n        if len(current) == len(nums):\r\n            result.append(current[:])  # Add a deep copy of the current permutation\r\n            return\r\n        \r\n        for i in range(len(nums)):\r\n            # Skip duplicates or already used elements\r\n            if used[i] or (i > 0 and nums[i] == nums[i - 1] and not used[i - 1]):\r\n                continue\r\n            current.append(nums[i])\r\n            used[i] = True\r\n            self.backtrack(nums, used, current, result)\r\n            current.pop()\r\n            used[i] = False\r\n\r\n\r\n\r\n#{ \r\n # Driver Code Starts\r\n        \r\nif __name__ == '__main__':\r\n    T=int(input())\r\n    for i in range(T):\r\n        n = int(input().strip())\r\n        nums = list(map(int, input().strip().split()))\r\n        obj = Solution()\r\n        ans = obj.permuteUnique(nums)\r\n        for i in ans:\r\n            for j in i:\r\n                print(j, end = \" \")\r\n            print()\r\n# } Driver Code Ends",
  "status": "1",
  "language": "python3",
  "user_code": "#User function Template for python3\r\n\r\nclass Solution:\r\n    def permuteUnique(self, nums):\r\n        nums.sort()  # Sort the input array to handle duplicates\r\n        result = []\r\n        used = [False] * len(nums)\r\n        self.backtrack(nums, used, [], result)\r\n        return result\r\n    \r\n    def backtrack(self, nums, used, current, result):\r\n        if len(current) == len(nums):\r\n            result.append(current[:])  # Add a deep copy of the current permutation\r\n            return\r\n        \r\n        for i in range(len(nums)):\r\n            # Skip duplicates or already used elements\r\n            if used[i] or (i > 0 and nums[i] == nums[i - 1] and not used[i - 1]):\r\n                continue\r\n            current.append(nums[i])\r\n            used[i] = True\r\n            self.backtrack(nums, used, current, result)\r\n            current.pop()\r\n            used[i] = False\r\n\r\n\r\n\r\n"
}