{
  "code": "import java.util.*;\r\nimport java.lang.*;\r\nimport java.io.*;\r\nclass GFG\r\n{\r\n    public static void main(String[] args) throws IOException\r\n    {\r\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n        int T = Integer.parseInt(br.readLine().trim());\r\n        while(T-->0)\r\n        {\r\n            int N = Integer.parseInt(br.readLine().trim());\r\n            String[] S1 = br.readLine().trim().split(\" \");\r\n            String[] S2 = br.readLine().trim().split(\" \");\r\n            int[] KnightPos = new int[2];\r\n            int[] TargetPos = new int[2];\r\n            for(int i = 0; i < 2; i++){\r\n                KnightPos[i] = Integer.parseInt(S1[i]);\r\n                TargetPos[i] = Integer.parseInt(S2[i]);\r\n            }\r\n            Solution obj = new Solution();\r\n            int ans = obj.minStepToReachTarget(KnightPos, TargetPos, N);\r\n            System.out.println(ans);\r\n       }\r\n    }\r\n}\r\n\r\n// } Driver Code Ends\r\n\r\n\r\n\r\n\r\n\r\nclass Solution\r\n{\r\n    //Function to find out minimum steps Knight needs to reach target position.\r\n    public int minStepToReachTarget(int KnightPos[], int TargetPos[], int N)\r\n    {\r\n        boolean[][] visited = new boolean[N + 1][N + 1];\r\n        for (int i = 0; i <= N; i++) {\r\n            Arrays.fill(visited[i], false);\r\n        }\r\n        return bfs(KnightPos[0], KnightPos[1], TargetPos[0], TargetPos[1], N, visited);\r\n        \r\n    }\r\n    \r\n    \r\n    public int bfs(int kx, int ky, int tx, int ty, int N, boolean[][] visited){\r\n        Queue<int[]> cells = new ArrayDeque<>();\r\n        int[] start = {kx, ky, 0};\r\n        cells.offer(start);\r\n        visited[kx][ky] = true;\r\n        \r\n        int[][] directions = {{-2, -1}, {-2, 1}, {-1, 2},\r\n        {1, 2}, {2, 1}, {2, -1}, {1, -2}, {-1, -2}};\r\n                              \r\n        while (!cells.isEmpty()) {\r\n            int[] cell = cells.poll();\r\n            int x = cell[0];\r\n            int y = cell[1];\r\n            int dist = cell[2];\r\n            \r\n            if (x == tx && y == ty) return dist;\r\n            \r\n            for (int[] dir: directions) {\r\n                int xx = x + dir[0];\r\n                int yy = y + dir[1];\r\n                \r\n                boolean out = xx < 1 || xx > N || yy < 1 || yy > N;\r\n                if (out || visited[xx][yy]) continue;\r\n                \r\n                int[] nbr = {xx, yy, dist + 1};\r\n                cells.offer(nbr);\r\n                visited[xx][yy] = true;\r\n            }\r\n        }\r\n        \r\n        return -1;\r\n    }\r\n        // Code here\r\n    }",
  "status": "1",
  "language": "java",
  "user_code": "\r\n\r\n\r\n\r\n\r\nclass Solution\r\n{\r\n    //Function to find out minimum steps Knight needs to reach target position.\r\n    public int minStepToReachTarget(int KnightPos[], int TargetPos[], int N)\r\n    {\r\n        boolean[][] visited = new boolean[N + 1][N + 1];\r\n        for (int i = 0; i <= N; i++) {\r\n            Arrays.fill(visited[i], false);\r\n        }\r\n        return bfs(KnightPos[0], KnightPos[1], TargetPos[0], TargetPos[1], N, visited);\r\n        \r\n    }\r\n    \r\n    \r\n    public int bfs(int kx, int ky, int tx, int ty, int N, boolean[][] visited){\r\n        Queue<int[]> cells = new ArrayDeque<>();\r\n        int[] start = {kx, ky, 0};\r\n        cells.offer(start);\r\n        visited[kx][ky] = true;\r\n        \r\n        int[][] directions = {{-2, -1}, {-2, 1}, {-1, 2},\r\n        {1, 2}, {2, 1}, {2, -1}, {1, -2}, {-1, -2}};\r\n                              \r\n        while (!cells.isEmpty()) {\r\n            int[] cell = cells.poll();\r\n            int x = cell[0];\r\n            int y = cell[1];\r\n            int dist = cell[2];\r\n            \r\n            if (x == tx && y == ty) return dist;\r\n            \r\n            for (int[] dir: directions) {\r\n                int xx = x + dir[0];\r\n                int yy = y + dir[1];\r\n                \r\n                boolean out = xx < 1 || xx > N || yy < 1 || yy > N;\r\n                if (out || visited[xx][yy]) continue;\r\n                \r\n                int[] nbr = {xx, yy, dist + 1};\r\n                cells.offer(nbr);\r\n                visited[xx][yy] = true;\r\n            }\r\n        }\r\n        \r\n        return -1;\r\n    }\r\n        // Code here\r\n    }"
}