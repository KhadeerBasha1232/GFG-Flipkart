{
  "code": "//Initial Template for Java\r\n\r\nimport java.util.*;\r\nimport java.math.*;\r\nimport java.io.*;\r\n\r\nclass FastReader{ \r\n\tBufferedReader br; \r\n\tStringTokenizer st; \r\n\r\n\tpublic FastReader(){ \r\n\t\tbr = new BufferedReader(new InputStreamReader(System.in)); \r\n\t} \r\n\r\n\tString next(){ \r\n\t\twhile (st == null || !st.hasMoreElements()){ \r\n\t\t\ttry{ st = new StringTokenizer(br.readLine()); } catch (IOException  e){ e.printStackTrace(); } \r\n\t\t} \r\n\t\treturn st.nextToken(); \r\n\t} \r\n\r\n\tString nextLine(){ \r\n\t\tString str = \"\"; \r\n\t\ttry{ str = br.readLine(); } catch (IOException e) { e.printStackTrace(); } \r\n\t\treturn str; \r\n\t} \r\n} \r\n\r\nclass Gfg\r\n{\r\n    public static void main(String args[])\r\n    {\r\n        FastReader sc = new FastReader();\r\n        PrintWriter out = new PrintWriter(System.out);\r\n        int t = Integer.parseInt(sc.next());\r\n        while(t-- > 0)\r\n        {\r\n            int k = Integer.parseInt(sc.next());\r\n            String s = sc.next();\r\n            Solution T = new Solution();\r\n            out.println(T.reduced_String(k, s));\r\n        }\r\n        out.flush();\r\n    }\r\n}\r\n\r\n// } Driver Code Ends\r\n\r\n\r\n//User function Template for Java\r\n\r\n/*\r\n    Note: Use StringBuilder/StringBuffer class for String concatenation(if any).\r\n    While using String class, on each concatenation a new copy of the string is created, so that \r\n    the overall complexity is O(n^2) . Fortunately in Java we could solve this with a StringBuffer/StringBuffer, \r\n    which has O(1) complexity for each append.\r\n*/\r\n\r\nclass Solution\r\n{\r\n    public static String reduced_String(int k, String s)\r\n    {\r\n        // Your code goes here\r\n        Stack<Character> st1=new Stack<>();\r\n        Stack<Integer> st2=new Stack<>();\r\n        for(int i=0;i<s.length();i++){\r\n            char ch=s.charAt(i);\r\n            if(!st1.isEmpty() && st1.peek()==ch){\r\n                st1.push(ch);\r\n                st2.push(st2.peek()+1);\r\n            }\r\n            else{\r\n                st1.push(ch);\r\n                st2.push(1);\r\n            }\r\n            if(st2.peek()==k){\r\n                int a=k;\r\n                while(a!=0){\r\n                    st1.pop();\r\n                    st2.pop();\r\n                    a--;\r\n                }\r\n            }\r\n        }\r\n        StringBuilder ans=new StringBuilder();\r\n        for(char ch:st1){\r\n            ans.append(ch);\r\n        }\r\n        return ans.toString();\r\n    }\r\n}\r\n\r\n",
  "status": "1",
  "language": "java",
  "user_code": "\r\n\r\n//User function Template for Java\r\n\r\n/*\r\n    Note: Use StringBuilder/StringBuffer class for String concatenation(if any).\r\n    While using String class, on each concatenation a new copy of the string is created, so that \r\n    the overall complexity is O(n^2) . Fortunately in Java we could solve this with a StringBuffer/StringBuffer, \r\n    which has O(1) complexity for each append.\r\n*/\r\n\r\nclass Solution\r\n{\r\n    public static String reduced_String(int k, String s)\r\n    {\r\n        // Your code goes here\r\n        Stack<Character> st1=new Stack<>();\r\n        Stack<Integer> st2=new Stack<>();\r\n        for(int i=0;i<s.length();i++){\r\n            char ch=s.charAt(i);\r\n            if(!st1.isEmpty() && st1.peek()==ch){\r\n                st1.push(ch);\r\n                st2.push(st2.peek()+1);\r\n            }\r\n            else{\r\n                st1.push(ch);\r\n                st2.push(1);\r\n            }\r\n            if(st2.peek()==k){\r\n                int a=k;\r\n                while(a!=0){\r\n                    st1.pop();\r\n                    st2.pop();\r\n                    a--;\r\n                }\r\n            }\r\n        }\r\n        StringBuilder ans=new StringBuilder();\r\n        for(char ch:st1){\r\n            ans.append(ch);\r\n        }\r\n        return ans.toString();\r\n    }\r\n}\r\n\r\n"
}