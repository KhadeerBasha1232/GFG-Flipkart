{
  "code": "//Initial Template for Java\r\n\r\nimport java.io.*;\r\nimport java.lang.*;\r\nimport java.util.*;\r\n\r\nclass GFG{\r\n\tpublic static void main(String [] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tint test = Integer.parseInt(br.readLine());\r\n\t\twhile(test-- > 0) {\r\n\t\t\tint n = Integer.parseInt(br.readLine());\r\n\t\t\tint [][] arr = new int[n][2];\r\n\t\t\tfor(int i = 0; i < n; i++){\r\n\t\t\t    String xy [] = br.readLine().trim().split(\" \");\r\n    \t\t\tarr[i][0] = Integer.parseInt(xy[0]);\r\n    \t\t\tarr[i][1] = Integer.parseInt(xy[1]);\r\n\t\t\t}\r\n\t\t\tString xy [] = br.readLine().trim().split(\" \");\r\n\t\t\tint x = Integer.parseInt(xy[0]);\r\n\t\t\tint y = Integer.parseInt(xy[1]);\r\n\t\t\tSolution obj = new Solution();\r\n\t\t\tif(obj.isInside(arr, x, y))\r\n\t\t\t\tSystem.out.println(\"Yes\");\r\n\t\t\telse\r\n\t\t\t\tSystem.out.println(\"No\");\r\n\t\t}\r\n\t}\r\n}\r\n// } Driver Code Ends\r\n\r\n\r\n//User function Template for Java\r\n\r\nclass Solution{\r\n    static class Point\r\n    {\r\n        int x;\r\n        int y;\r\n \r\n        public Point(int x, int y)\r\n        {\r\n            this.x = x;\r\n            this.y = y;\r\n        }\r\n    }\r\n    static boolean onSegment(Point p, Point q, Point r)\r\n    {\r\n        if (q.x <= Math.max(p.x, r.x) &&\r\n            q.x >= Math.min(p.x, r.x) &&\r\n            q.y <= Math.max(p.y, r.y) &&\r\n            q.y >= Math.min(p.y, r.y))\r\n        {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    static int orientation(Point p, Point q, Point r)\r\n    {\r\n        int val = (q.y - p.y) * (r.x - q.x)\r\n                - (q.x - p.x) * (r.y - q.y);\r\n \r\n        if (val == 0)\r\n        {\r\n            return 0;\r\n        }\r\n        return (val > 0) ? 1 : 2;\r\n    }\r\n    static boolean doIntersect(Point p1, Point q1,\r\n                            Point p2, Point q2)\r\n    {\r\n        int o1 = orientation(p1, q1, p2);\r\n        int o2 = orientation(p1, q1, q2);\r\n        int o3 = orientation(p2, q2, p1);\r\n        int o4 = orientation(p2, q2, q1);\r\n        if (o1 != o2 && o3 != o4)\r\n        {\r\n            return true;\r\n        }\r\n        if (o1 == 0 && onSegment(p1, p2, q1))\r\n        {\r\n            return true;\r\n        }\r\n        if (o2 == 0 && onSegment(p1, q2, q1))\r\n        {\r\n            return true;\r\n        }\r\n        if (o3 == 0 && onSegment(p2, p1, q2))\r\n        {\r\n            return true;\r\n        }\r\n        if (o4 == 0 && onSegment(p2, q1, q2))\r\n        {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\npublic boolean isInside(int [][] arr, int x, int y) {\r\n    if (arr.length < 3)\r\n        {\r\n            return false;\r\n        }\r\n        Point p = new Point(x,y);\r\n        Point extreme = new Point(Integer.MAX_VALUE, y);\r\n        int count = 0, i = 0;\r\n        while(true)\r\n        {\r\n            int next = (i + 1) % arr.length;\r\n            Point p1 = new Point(arr[i][0], arr[i][1]);\r\n            Point p2 = new Point(arr[next][0], arr[next][1]);\r\n            if (doIntersect(p1, p2, p, extreme))\r\n            {\r\n                if (orientation(p1, p, p2) == 0)\r\n                {\r\n                    return onSegment(p1, p, p2);\r\n                }\r\n \r\n                count++;\r\n            }\r\n            i = next;\r\n            if(i==0)\r\n            break;\r\n        } \r\n        return (count % 2 == 1);\r\n}\r\n}",
  "status": "1",
  "language": "java",
  "user_code": "\r\n\r\n//User function Template for Java\r\n\r\nclass Solution{\r\n    static class Point\r\n    {\r\n        int x;\r\n        int y;\r\n \r\n        public Point(int x, int y)\r\n        {\r\n            this.x = x;\r\n            this.y = y;\r\n        }\r\n    }\r\n    static boolean onSegment(Point p, Point q, Point r)\r\n    {\r\n        if (q.x <= Math.max(p.x, r.x) &&\r\n            q.x >= Math.min(p.x, r.x) &&\r\n            q.y <= Math.max(p.y, r.y) &&\r\n            q.y >= Math.min(p.y, r.y))\r\n        {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    static int orientation(Point p, Point q, Point r)\r\n    {\r\n        int val = (q.y - p.y) * (r.x - q.x)\r\n                - (q.x - p.x) * (r.y - q.y);\r\n \r\n        if (val == 0)\r\n        {\r\n            return 0;\r\n        }\r\n        return (val > 0) ? 1 : 2;\r\n    }\r\n    static boolean doIntersect(Point p1, Point q1,\r\n                            Point p2, Point q2)\r\n    {\r\n        int o1 = orientation(p1, q1, p2);\r\n        int o2 = orientation(p1, q1, q2);\r\n        int o3 = orientation(p2, q2, p1);\r\n        int o4 = orientation(p2, q2, q1);\r\n        if (o1 != o2 && o3 != o4)\r\n        {\r\n            return true;\r\n        }\r\n        if (o1 == 0 && onSegment(p1, p2, q1))\r\n        {\r\n            return true;\r\n        }\r\n        if (o2 == 0 && onSegment(p1, q2, q1))\r\n        {\r\n            return true;\r\n        }\r\n        if (o3 == 0 && onSegment(p2, p1, q2))\r\n        {\r\n            return true;\r\n        }\r\n        if (o4 == 0 && onSegment(p2, q1, q2))\r\n        {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\npublic boolean isInside(int [][] arr, int x, int y) {\r\n    if (arr.length < 3)\r\n        {\r\n            return false;\r\n        }\r\n        Point p = new Point(x,y);\r\n        Point extreme = new Point(Integer.MAX_VALUE, y);\r\n        int count = 0, i = 0;\r\n        while(true)\r\n        {\r\n            int next = (i + 1) % arr.length;\r\n            Point p1 = new Point(arr[i][0], arr[i][1]);\r\n            Point p2 = new Point(arr[next][0], arr[next][1]);\r\n            if (doIntersect(p1, p2, p, extreme))\r\n            {\r\n                if (orientation(p1, p, p2) == 0)\r\n                {\r\n                    return onSegment(p1, p, p2);\r\n                }\r\n \r\n                count++;\r\n            }\r\n            i = next;\r\n            if(i==0)\r\n            break;\r\n        } \r\n        return (count % 2 == 1);\r\n}\r\n}"
}