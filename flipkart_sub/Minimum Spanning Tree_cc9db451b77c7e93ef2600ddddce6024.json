{
  "code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\n// } Driver Code Ends\r\n\r\nclass DisjointSet {\r\n    vector<int> rank, parent, size;\r\npublic:\r\n    DisjointSet(int n) {\r\n        rank.resize(n + 1, 0);\r\n        parent.resize(n + 1);\r\n        size.resize(n + 1);\r\n        for (int i = 0; i <= n; i++) {\r\n            parent[i] = i;\r\n            size[i] = 1;\r\n        }\r\n    }\r\n\r\n    int findUPar(int node) {\r\n        if (node == parent[node])\r\n            return node;\r\n        return parent[node] = findUPar(parent[node]);\r\n    }\r\n\r\n    void unionByRank(int u, int v) {\r\n        int ulp_u = findUPar(u);\r\n        int ulp_v = findUPar(v);\r\n        if (ulp_u == ulp_v) return;\r\n        if (rank[ulp_u] < rank[ulp_v]) {\r\n            parent[ulp_u] = ulp_v;\r\n        }\r\n        else if (rank[ulp_v] < rank[ulp_u]) {\r\n            parent[ulp_v] = ulp_u;\r\n        }\r\n        else {\r\n            parent[ulp_v] = ulp_u;\r\n            rank[ulp_u]++;\r\n        }\r\n    }\r\n\r\n    void unionBySize(int u, int v) {\r\n        int ulp_u = findUPar(u);\r\n        int ulp_v = findUPar(v);\r\n        if (ulp_u == ulp_v) return;\r\n        if (size[ulp_u] < size[ulp_v]) {\r\n            parent[ulp_u] = ulp_v;\r\n            size[ulp_v] += size[ulp_u];\r\n        }\r\n        else {\r\n            parent[ulp_v] = ulp_u;\r\n            size[ulp_u] += size[ulp_v];\r\n        }\r\n    }\r\n};\r\n\r\nclass Solution\r\n{\r\n\tpublic:\r\n\t//Function to find sum of weights of edges of the Minimum Spanning Tree.\r\n    int spanningTree(int V, vector<vector<int>> adj[])\r\n    {\r\n        // code here\r\n        vector<pair<int, pair<int,int>>> edges;\r\n        \r\n        for(int i = 0; i < V; i++) {\r\n            for(auto it: adj[i]) {\r\n                int adjNode = it[0];\r\n                int wt = it[1];\r\n                int node = i;\r\n                \r\n                edges.push_back({wt, {node, adjNode}});\r\n            }\r\n        }\r\n        DisjointSet ds(V);\r\n        \r\n        sort(edges.begin(), edges.end());\r\n        int mstWt = 0;\r\n        \r\n        for(auto it: edges) {\r\n            int wt = it.first;\r\n            int u = it.second.first;\r\n            int v = it.second.second;\r\n            \r\n            if(ds.findUPar(u) != ds.findUPar(v)) {\r\n                //if it is not having same parent \r\n                //then we have union them \r\n                mstWt += wt;\r\n                ds.unionBySize(u, v);\r\n            }\r\n        }\r\n        \r\n        return mstWt;\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//{ Driver Code Starts.\r\n\r\n\r\nint main()\r\n{\r\n    int t;\r\n    cin >> t;\r\n    while (t--) {\r\n        int V, E;\r\n        cin >> V >> E;\r\n        vector<vector<int>> adj[V];\r\n        int i=0;\r\n        while (i++<E) {\r\n            int u, v, w;\r\n            cin >> u >> v >> w;\r\n            vector<int> t1,t2;\r\n            t1.push_back(v);\r\n            t1.push_back(w);\r\n            adj[u].push_back(t1);\r\n            t2.push_back(u);\r\n            t2.push_back(w);\r\n            adj[v].push_back(t2);\r\n        }\r\n        \r\n        Solution obj;\r\n    \tcout << obj.spanningTree(V, adj) << \"\\n\";\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n\r\n// } Driver Code Ends",
  "status": "1",
  "language": "cpp",
  "user_code": "\r\nclass DisjointSet {\r\n    vector<int> rank, parent, size;\r\npublic:\r\n    DisjointSet(int n) {\r\n        rank.resize(n + 1, 0);\r\n        parent.resize(n + 1);\r\n        size.resize(n + 1);\r\n        for (int i = 0; i <= n; i++) {\r\n            parent[i] = i;\r\n            size[i] = 1;\r\n        }\r\n    }\r\n\r\n    int findUPar(int node) {\r\n        if (node == parent[node])\r\n            return node;\r\n        return parent[node] = findUPar(parent[node]);\r\n    }\r\n\r\n    void unionByRank(int u, int v) {\r\n        int ulp_u = findUPar(u);\r\n        int ulp_v = findUPar(v);\r\n        if (ulp_u == ulp_v) return;\r\n        if (rank[ulp_u] < rank[ulp_v]) {\r\n            parent[ulp_u] = ulp_v;\r\n        }\r\n        else if (rank[ulp_v] < rank[ulp_u]) {\r\n            parent[ulp_v] = ulp_u;\r\n        }\r\n        else {\r\n            parent[ulp_v] = ulp_u;\r\n            rank[ulp_u]++;\r\n        }\r\n    }\r\n\r\n    void unionBySize(int u, int v) {\r\n        int ulp_u = findUPar(u);\r\n        int ulp_v = findUPar(v);\r\n        if (ulp_u == ulp_v) return;\r\n        if (size[ulp_u] < size[ulp_v]) {\r\n            parent[ulp_u] = ulp_v;\r\n            size[ulp_v] += size[ulp_u];\r\n        }\r\n        else {\r\n            parent[ulp_v] = ulp_u;\r\n            size[ulp_u] += size[ulp_v];\r\n        }\r\n    }\r\n};\r\n\r\nclass Solution\r\n{\r\n\tpublic:\r\n\t//Function to find sum of weights of edges of the Minimum Spanning Tree.\r\n    int spanningTree(int V, vector<vector<int>> adj[])\r\n    {\r\n        // code here\r\n        vector<pair<int, pair<int,int>>> edges;\r\n        \r\n        for(int i = 0; i < V; i++) {\r\n            for(auto it: adj[i]) {\r\n                int adjNode = it[0];\r\n                int wt = it[1];\r\n                int node = i;\r\n                \r\n                edges.push_back({wt, {node, adjNode}});\r\n            }\r\n        }\r\n        DisjointSet ds(V);\r\n        \r\n        sort(edges.begin(), edges.end());\r\n        int mstWt = 0;\r\n        \r\n        for(auto it: edges) {\r\n            int wt = it.first;\r\n            int u = it.second.first;\r\n            int v = it.second.second;\r\n            \r\n            if(ds.findUPar(u) != ds.findUPar(v)) {\r\n                //if it is not having same parent \r\n                //then we have union them \r\n                mstWt += wt;\r\n                ds.unionBySize(u, v);\r\n            }\r\n        }\r\n        \r\n        return mstWt;\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
}