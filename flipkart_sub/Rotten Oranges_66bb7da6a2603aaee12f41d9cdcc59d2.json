{
  "code": "\r\n    #Function to find minimum time required to rot all oranges. \r\n    def orangesRotting(self, grid):\r\n        #Code here\r\n        N = len(grid)\r\n        M = len(grid[0])\r\n        adj = []\r\n        for i in range(M*N):\r\n            neigh = []\r\n            if i - 1 >= 0 and (i)%M != 0:\r\n                neigh.append(i-1)\r\n            if i - M >= 0 :\r\n                neigh.append(i-M)\r\n            if i + 1 < N*M and (i+1)%M != 0:\r\n                neigh.append(i+1)\r\n            if i + M <M*N:\r\n                neigh.append(i+M)\r\n            adj.append(neigh)\r\n        rotten = []\r\n        empty = []\r\n        el_id = -1\r\n        for i in range(N):\r\n            for j in range(M):\r\n                el_id+=1\r\n                if grid[i][j] == 0:\r\n                    empty.append(el_id)\r\n                if grid[i][j]== 2:\r\n                    rotten.append(el_id)\r\n        if len(empty) == M*N:\r\n            return 0\r\n        mins=-1\r\n        visited = []\r\n        while True:\r\n            if not rotten:\r\n                break\r\n            mins+=1\r\n            rot = []\r\n            while rotten:\r\n                cur = rotten.pop()\r\n                visited.append(cur)\r\n                for i in adj[cur]:\r\n                    if i not in visited and i not in empty and i not in rotten:\r\n                        rot.append(i)\r\n            rotten+=rot\r\n        if len(set(visited))<(M*N-len(empty)):\r\n            return -1\r\n        return mins\r\n\r\n#{ \r\n # Driver Code Starts\r\nfrom queue import Queue\r\n\r\n\r\nT=int(input())\r\nfor i in range(T):\r\n    n, m = map(int, input().split())\r\n    grid = []\r\n    for _ in range(n):\r\n        a = list(map(int, input().split()))\r\n        grid.append(a)\r\n    obj = Solution()\r\n    ans = obj.orangesRotting(grid)\r\n    print(ans)\r\n\r\n# } Driver Code Ends",
  "status": "11",
  "language": "python3",
  "user_code": "class Solution:\r\n\r\n    #Function to find minimum time required to rot all oranges. \r\n    def orangesRotting(self, grid):\r\n        #Code here\r\n        N = len(grid)\r\n        M = len(grid[0])\r\n        adj = []\r\n        for i in range(M*N):\r\n            neigh = []\r\n            if i - 1 >= 0 and (i)%M != 0:\r\n                neigh.append(i-1)\r\n            if i - M >= 0 :\r\n                neigh.append(i-M)\r\n            if i + 1 < N*M and (i+1)%M != 0:\r\n                neigh.append(i+1)\r\n            if i + M <M*N:\r\n                neigh.append(i+M)\r\n            adj.append(neigh)\r\n        rotten = []\r\n        empty = []\r\n        el_id = -1\r\n        for i in range(N):\r\n            for j in range(M):\r\n                el_id+=1\r\n                if grid[i][j] == 0:\r\n                    empty.append(el_id)\r\n                if grid[i][j]== 2:\r\n                    rotten.append(el_id)\r\n        if len(empty) == M*N:\r\n            return 0\r\n        mins=-1\r\n        visited = []\r\n        while True:\r\n            if not rotten:\r\n                break\r\n            mins+=1\r\n            rot = []\r\n            while rotten:\r\n                cur = rotten.pop()\r\n                visited.append(cur)\r\n                for i in adj[cur]:\r\n                    if i not in visited and i not in empty and i not in rotten:\r\n                        rot.append(i)\r\n            rotten+=rot\r\n        if len(set(visited))<(M*N-len(empty)):\r\n            return -1\r\n        return mins\r\n\r\n"
}