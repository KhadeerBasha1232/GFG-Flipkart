{
  "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define MAX_HEIGHT 100000\r\n\r\n// Tree Node\r\nstruct Node {\r\n    int data;\r\n    Node *left;\r\n    Node *right;\r\n\r\n    Node(int val) {\r\n        data = val;\r\n        left = right = NULL;\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\n// } Driver Code Ends\r\nclass Solution\r\n{\r\n    public:\r\n    //Function to check whether a Binary Tree is BST or not.\r\n    void solve(Node* root, bool &res, int &prev) {\r\n        if(!root)   return;\r\n        \r\n        solve(root->left,res,prev);\r\n        if(root->data <= prev) {\r\n            res = false;\r\n            return;\r\n        }\r\n        prev = root->data;\r\n        solve(root->right, res, prev);\r\n    }\r\n\r\n    bool isBST(Node* root) {\r\n        bool res = true;\r\n        int prev = -1;\r\n        solve(root, res, prev);\r\n        \r\n        return res;\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\n//{ Driver Code Starts.\r\n\r\n// Function to Build Tree\r\nNode* buildTree(string str)\r\n{\r\n   // Corner Case\r\n   if(str.length() == 0 || str[0] == 'N')\r\n       return NULL;\r\n\r\n   // Creating vector of strings from input\r\n   // string after spliting by space\r\n   vector<string> ip;\r\n\r\n   istringstream iss(str);\r\n   for(string str; iss >> str; )\r\n       ip.push_back(str);\r\n\r\n   // Create the root of the tree\r\n   Node* root = new Node(stoi(ip[0]));\r\n\r\n   // Push the root to the queue\r\n   queue<Node*> queue;\r\n   queue.push(root);\r\n\r\n   // Starting from the second element\r\n   int i = 1;\r\n   while(!queue.empty() && i < ip.size()) {\r\n\r\n       // Get and remove the front of the queue\r\n       Node* currNode = queue.front();\r\n       queue.pop();\r\n\r\n       // Get the current node's value from the string\r\n       string currVal = ip[i];\r\n\r\n       // If the left child is not null\r\n       if(currVal != \"N\") {\r\n\r\n           // Create the left child for the current node\r\n           currNode->left = new Node(stoi(currVal));\r\n\r\n           // Push it to the queue\r\n           queue.push(currNode->left);\r\n       }\r\n\r\n       // For the right child\r\n       i++;\r\n       if(i >= ip.size())\r\n           break;\r\n       currVal = ip[i];\r\n\r\n       // If the right child is not null\r\n       if(currVal != \"N\") {\r\n\r\n           // Create the right child for the current node\r\n           currNode->right = new Node(stoi(currVal));\r\n\r\n           // Push it to the queue\r\n           queue.push(currNode->right);\r\n       }\r\n       i++;\r\n   }\r\n\r\n   return root;\r\n}\r\n\r\nvoid inorder(Node *root, vector<int> &v)\r\n{\r\n    if(root==NULL)\r\n        return;\r\n\r\n    inorder(root->left, v);\r\n    v.push_back(root->data);\r\n    inorder(root->right, v);\r\n}\r\n\r\nint main() {\r\n \r\n   int t;\r\n   string tc;\r\n   getline(cin, tc);\r\n   t=stoi(tc);\r\n   while(t--)\r\n   {\r\n    string s; \r\n    getline(cin, s);\r\n    Node* root = buildTree(s);\r\n    Solution ob;\r\n    if(ob.isBST(root)) \r\n        cout<<\"1\\n\";\r\n        \r\n    else\r\n        cout<<\"0\\n\";\r\n   }\r\n   return 0;\r\n}\r\n\r\n\r\n// } Driver Code Ends",
  "status": "1",
  "language": "cpp",
  "user_code": "class Solution\r\n{\r\n    public:\r\n    //Function to check whether a Binary Tree is BST or not.\r\n    void solve(Node* root, bool &res, int &prev) {\r\n        if(!root)   return;\r\n        \r\n        solve(root->left,res,prev);\r\n        if(root->data <= prev) {\r\n            res = false;\r\n            return;\r\n        }\r\n        prev = root->data;\r\n        solve(root->right, res, prev);\r\n    }\r\n\r\n    bool isBST(Node* root) {\r\n        bool res = true;\r\n        int prev = -1;\r\n        solve(root, res, prev);\r\n        \r\n        return res;\r\n    }\r\n};\r\n\r\n\r\n\r\n"
}