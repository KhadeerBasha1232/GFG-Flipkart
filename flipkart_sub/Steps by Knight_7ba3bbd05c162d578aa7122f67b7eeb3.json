{
  "code": "import java.util.*;\r\nimport java.lang.*;\r\nimport java.io.*;\r\nclass GFG\r\n{\r\n    public static void main(String[] args) throws IOException\r\n    {\r\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n        int T = Integer.parseInt(br.readLine().trim());\r\n        while(T-->0)\r\n        {\r\n            int N = Integer.parseInt(br.readLine().trim());\r\n            String[] S1 = br.readLine().trim().split(\" \");\r\n            String[] S2 = br.readLine().trim().split(\" \");\r\n            int[] KnightPos = new int[2];\r\n            int[] TargetPos = new int[2];\r\n            for(int i = 0; i < 2; i++){\r\n                KnightPos[i] = Integer.parseInt(S1[i]);\r\n                TargetPos[i] = Integer.parseInt(S2[i]);\r\n            }\r\n            Solution obj = new Solution();\r\n            int ans = obj.minStepToReachTarget(KnightPos, TargetPos, N);\r\n            System.out.println(ans);\r\n       }\r\n    }\r\n}\r\n\r\n// } Driver Code Ends\r\n\r\n\r\n\r\n\r\nclass Solution {\r\n    public int minStepToReachTarget(int[] KnightPos, int[] TargetPos, int N) {\r\n        // Possible moves for a Knight\r\n        int[] dx = { -2, -1, 1, 2, -2, -1, 1, 2 };\r\n        int[] dy = { -1, -2, -2, -1, 1, 2, 2, 1 };\r\n\r\n        // 1-based indexing\r\n        int startX = KnightPos[0];\r\n        int startY = KnightPos[1];\r\n        int targetX = TargetPos[0];\r\n        int targetY = TargetPos[1];\r\n\r\n        // Initialize the chessboard with 0-based indexing\r\n        startX--;\r\n        startY--;\r\n        targetX--;\r\n        targetY--;\r\n\r\n        // Queue for BFS\r\n        Queue<int[]> queue = new LinkedList<>();\r\n        boolean[][] visited = new boolean[N][N];\r\n\r\n        // Enqueue starting position\r\n        queue.offer(new int[]{startX, startY, 0});\r\n        visited[startX][startY] = true;\r\n\r\n        while (!queue.isEmpty()) {\r\n            int[] current = queue.poll();\r\n            int x = current[0];\r\n            int y = current[1];\r\n            int steps = current[2];\r\n\r\n            // Check if the Knight has reached the target\r\n            if (x == targetX && y == targetY) {\r\n                return steps;\r\n            }\r\n\r\n            // Explore all possible moves\r\n            for (int i = 0; i < 8; i++) {\r\n                int nx = x + dx[i];\r\n                int ny = y + dy[i];\r\n\r\n                // Check if the new position is valid and not visited\r\n                if (nx >= 0 && nx < N && ny >= 0 && ny < N && !visited[nx][ny]) {\r\n                    queue.offer(new int[]{nx, ny, steps + 1});\r\n                    visited[nx][ny] = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        // If the target is unreachable\r\n        return -1;\r\n    }\r\n}\r\n",
  "status": "1",
  "language": "java",
  "user_code": "\r\n\r\n\r\n\r\nclass Solution {\r\n    public int minStepToReachTarget(int[] KnightPos, int[] TargetPos, int N) {\r\n        // Possible moves for a Knight\r\n        int[] dx = { -2, -1, 1, 2, -2, -1, 1, 2 };\r\n        int[] dy = { -1, -2, -2, -1, 1, 2, 2, 1 };\r\n\r\n        // 1-based indexing\r\n        int startX = KnightPos[0];\r\n        int startY = KnightPos[1];\r\n        int targetX = TargetPos[0];\r\n        int targetY = TargetPos[1];\r\n\r\n        // Initialize the chessboard with 0-based indexing\r\n        startX--;\r\n        startY--;\r\n        targetX--;\r\n        targetY--;\r\n\r\n        // Queue for BFS\r\n        Queue<int[]> queue = new LinkedList<>();\r\n        boolean[][] visited = new boolean[N][N];\r\n\r\n        // Enqueue starting position\r\n        queue.offer(new int[]{startX, startY, 0});\r\n        visited[startX][startY] = true;\r\n\r\n        while (!queue.isEmpty()) {\r\n            int[] current = queue.poll();\r\n            int x = current[0];\r\n            int y = current[1];\r\n            int steps = current[2];\r\n\r\n            // Check if the Knight has reached the target\r\n            if (x == targetX && y == targetY) {\r\n                return steps;\r\n            }\r\n\r\n            // Explore all possible moves\r\n            for (int i = 0; i < 8; i++) {\r\n                int nx = x + dx[i];\r\n                int ny = y + dy[i];\r\n\r\n                // Check if the new position is valid and not visited\r\n                if (nx >= 0 && nx < N && ny >= 0 && ny < N && !visited[nx][ny]) {\r\n                    queue.offer(new int[]{nx, ny, steps + 1});\r\n                    visited[nx][ny] = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        // If the target is unreachable\r\n        return -1;\r\n    }\r\n}\r\n"
}