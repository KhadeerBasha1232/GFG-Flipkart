{
  "code": "/* Driver program to test above function */\r\n\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\n// } Driver Code Ends\r\n//Back-end complete function Template for C++\r\n\r\n#include <vector>\r\n#include <algorithm>\r\nusing namespace std;\r\n\r\nclass Solution {\r\nprivate:\r\n    pair<int, int> dfs(int node, vector<vector<int>>& adj, int par) {\r\n        pair<int, int> result = {0, node}; // depth and farthest leaf\r\n        for (int next : adj[node]) {\r\n            if (next != par) {\r\n                auto nextResult = dfs(next, adj, node);\r\n                if (nextResult.first + 1 > result.first) {\r\n                    result.first = nextResult.first + 1;\r\n                    result.second = nextResult.second;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\npublic:\r\n    int findMaxDist(vector<int>& parent, int n) {\r\n        vector<vector<int>> adj(n);\r\n        int root;\r\n        for (int i = 0; i < n; ++i) {\r\n            if (parent[i] == -1) {\r\n                root = i;\r\n            } else {\r\n                adj[parent[i]].push_back(i);\r\n                adj[i].push_back(parent[i]);\r\n            }\r\n        }\r\n        auto farthestLeaf = dfs(root, adj, -1);\r\n        auto result = dfs(farthestLeaf.second, adj, -1);\r\n        return result.first;\r\n    }\r\n};\r\n\r\n\r\n\r\n//{ Driver Code Starts.\r\nint main()\r\n{\r\n\tint t;\r\n\tcin>>t;\r\n\twhile(t--)\r\n\t{\r\n\t    int n;\r\n\t    cin>>n;\r\n\t    vector<int>arr(n);\r\n\t    for(int i=0;i<n;i++){\r\n\t      cin>>arr[i];\r\n\t    }\r\n\t    Solution ob;  \r\n\t    int ans=ob.findMaxDist(arr, n);\r\n\t    cout<<ans;\r\n\t    cout<<\"\\n\";\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\n// } Driver Code Ends",
  "status": "1",
  "language": "cpp",
  "user_code": "//Back-end complete function Template for C++\r\n\r\n#include <vector>\r\n#include <algorithm>\r\nusing namespace std;\r\n\r\nclass Solution {\r\nprivate:\r\n    pair<int, int> dfs(int node, vector<vector<int>>& adj, int par) {\r\n        pair<int, int> result = {0, node}; // depth and farthest leaf\r\n        for (int next : adj[node]) {\r\n            if (next != par) {\r\n                auto nextResult = dfs(next, adj, node);\r\n                if (nextResult.first + 1 > result.first) {\r\n                    result.first = nextResult.first + 1;\r\n                    result.second = nextResult.second;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\npublic:\r\n    int findMaxDist(vector<int>& parent, int n) {\r\n        vector<vector<int>> adj(n);\r\n        int root;\r\n        for (int i = 0; i < n; ++i) {\r\n            if (parent[i] == -1) {\r\n                root = i;\r\n            } else {\r\n                adj[parent[i]].push_back(i);\r\n                adj[i].push_back(parent[i]);\r\n            }\r\n        }\r\n        auto farthestLeaf = dfs(root, adj, -1);\r\n        auto result = dfs(farthestLeaf.second, adj, -1);\r\n        return result.first;\r\n    }\r\n};\r\n\r\n\r\n"
}