{
  "code": "// Initial template for C++\r\n\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n\r\n// } Driver Code Ends\r\n// User function template for C++\r\n\r\nclass Solution{\r\n    public:\r\n\r\n\r\nvoid findPathRecursiveBT(int i, int j, vector<vector<int>>& m, string path, vector<string>& res, int n, int dirx[], int diry[])\r\n{\r\n\tif (i == n - 1 && j == n - 1)\r\n\t{\r\n\t\tres.push_back(path);\r\n\t\treturn;\r\n\t}\r\n\r\n\tstring dir = \"DLRU\";\r\n\r\n\tfor (int x = 0; x < 4; x++)\r\n\t{\r\n\t\tint nexti = i + dirx[x];\r\n\t\tint nextj = j + diry[x];\r\n\r\n\t\tif (nexti >= 0 && nextj >= 0 && nexti < n && nextj < n && m[nexti][nextj] == 1)\r\n\t\t{\r\n\t\t\tm[nexti][nextj] = -1;\r\n\t\t\tfindPathRecursiveBT(nexti, nextj, m, path + dir[x], res, n, dirx, diry);\r\n\t\t\tm[nexti][nextj] = 1;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvector<string> findPath(vector<vector<int>>& m, int n)\r\n{\r\n\tvector<string> res;\r\n\t//vector<vector<int>> visited(n, vector<int>(n, 0));\r\n\tint dirx[] = { 1, 0, 0, -1 };\r\n\tint diry[] = { 0, -1, 1, 0 };\r\n\tif (m[0][0] == 1)\r\n\t{\r\n\t    m[0][0] = -1;\r\n\t\tfindPathRecursiveBT(0, 0, m, \"\", res, n, dirx, diry);\r\n\t}\r\n\r\n\treturn res;\r\n}\r\n};\r\n\r\n    \r\n\r\n\r\n//{ Driver Code Starts.\r\n\r\nint main() {\r\n    int t;\r\n    cin >> t;\r\n    while (t--) {\r\n        int n;\r\n        cin >> n;\r\n        vector<vector<int>> m(n, vector<int> (n,0));\r\n        for (int i = 0; i < n; i++) {\r\n            for (int j = 0; j < n; j++) {\r\n                cin >> m[i][j];\r\n            }\r\n        }\r\n        Solution obj;\r\n        vector<string> result = obj.findPath(m, n);\r\n        sort(result.begin(), result.end());\r\n        if (result.size() == 0)\r\n            cout << -1;\r\n        else\r\n            for (int i = 0; i < result.size(); i++) cout << result[i] << \" \";\r\n        cout << endl;\r\n    }\r\n    return 0;\r\n}\r\n// } Driver Code Ends",
  "status": "1",
  "language": "cpp",
  "user_code": "// User function template for C++\r\n\r\nclass Solution{\r\n    public:\r\n\r\n\r\nvoid findPathRecursiveBT(int i, int j, vector<vector<int>>& m, string path, vector<string>& res, int n, int dirx[], int diry[])\r\n{\r\n\tif (i == n - 1 && j == n - 1)\r\n\t{\r\n\t\tres.push_back(path);\r\n\t\treturn;\r\n\t}\r\n\r\n\tstring dir = \"DLRU\";\r\n\r\n\tfor (int x = 0; x < 4; x++)\r\n\t{\r\n\t\tint nexti = i + dirx[x];\r\n\t\tint nextj = j + diry[x];\r\n\r\n\t\tif (nexti >= 0 && nextj >= 0 && nexti < n && nextj < n && m[nexti][nextj] == 1)\r\n\t\t{\r\n\t\t\tm[nexti][nextj] = -1;\r\n\t\t\tfindPathRecursiveBT(nexti, nextj, m, path + dir[x], res, n, dirx, diry);\r\n\t\t\tm[nexti][nextj] = 1;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvector<string> findPath(vector<vector<int>>& m, int n)\r\n{\r\n\tvector<string> res;\r\n\t//vector<vector<int>> visited(n, vector<int>(n, 0));\r\n\tint dirx[] = { 1, 0, 0, -1 };\r\n\tint diry[] = { 0, -1, 1, 0 };\r\n\tif (m[0][0] == 1)\r\n\t{\r\n\t    m[0][0] = -1;\r\n\t\tfindPathRecursiveBT(0, 0, m, \"\", res, n, dirx, diry);\r\n\t}\r\n\r\n\treturn res;\r\n}\r\n};\r\n\r\n    \r\n\r\n"
}