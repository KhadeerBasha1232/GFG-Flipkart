{
  "code": "//Initial Template for Java\r\n\r\nimport java.util.*;\r\nimport java.lang.*;\r\nimport java.io.*;\r\n\r\nclass GFG{\r\n\tpublic static void main(String [] args) throws IOException{\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tint test = Integer.parseInt(br.readLine());\r\n\t\twhile(test-- > 0) {\r\n\t\t\tint n = Integer.parseInt(br.readLine());\r\n\t\t\tString [] str = br.readLine().trim().split(\" \");\r\n\t\t\tint [] arr = new int[n];\r\n\t\t\tfor(int i = 0; i < n; i++)\r\n\t\t\t\tarr[i] = Integer.parseInt(str[i]);\r\n\t\t\tint k = Integer.parseInt(br.readLine());\r\n\t\t\tSolution obj = new Solution();\r\n\t\t\tSystem.out.println(obj.largestMinDist(arr, n, k));\r\n\t\t}\r\n\t}\r\n}\r\n// } Driver Code Ends\r\n\r\n\r\n\r\n\r\n//User function Template for Java\r\n\r\n\r\nclass Solution{\r\n\tstatic boolean isFeasible(int mid, int arr[], int n, \r\n                              int k) \r\n    { \r\n        // Place first element at arr[0] position \r\n        int pos = arr[0]; \r\n  \r\n        // Initialize count of elements placed. \r\n        int elements = 1; \r\n  \r\n        // Try placing k elements with minimum \r\n        // distance mid. \r\n        for (int i = 1; i < n; i++) { \r\n            if (arr[i] - pos >= mid) { \r\n                // Place next element if its \r\n                // distance from the previously \r\n                // placed element is greater \r\n                // than current mid \r\n                pos = arr[i]; \r\n                elements++; \r\n  \r\n                // Return if all elements are \r\n                // placed successfully \r\n                if (elements == k) \r\n                    return true; \r\n            } \r\n        } \r\n        return false; \r\n    } \r\n  \r\n    // Returns largest minimum distance for \r\n    // k elements in arr[0..n-1]. If elements \r\n    // can't be placed, returns -1. \r\n    static int largestMinDist(int arr[], int n, int k) \r\n    { \r\n        // Sort the positions \r\n        Arrays.sort(arr); \r\n  \r\n        // Initialize result. \r\n        int res = -1; \r\n  \r\n        // Consider the maximum possible distance \r\n        int left = 1, right = arr[n - 1]; \r\n  \r\n        // left is initialized with 1 and not with arr[0] \r\n        // because, minimum distance between each element \r\n        // can be one and not arr[0]. consider this example: \r\n        // arr[] = {9,12} and you have to place 2 element \r\n        // then left = arr[0] will force the function to \r\n        // look the answer between range arr[0] to arr[n-1], \r\n        // i.e 9 to 12, but the answer is 3 so It is \r\n        // required that you initialize the left with 1 \r\n  \r\n        // Do binary search for largest \r\n        // minimum distance \r\n        while (left < right) { \r\n            int mid = (left + right) / 2; \r\n  \r\n            // If it is possible to place k \r\n            // elements with minimum distance mid, \r\n            // search for higher distance. \r\n            if (isFeasible(mid, arr, n, k)) { \r\n                // Change value of variable max to \r\n                // mid if all elements can be \r\n                // successfully placed \r\n                res = Math.max(res, mid); \r\n                left = mid + 1; \r\n            } \r\n  \r\n            // If not possible to place k elements, \r\n            // search for lower distance \r\n            else\r\n                right = mid; \r\n        } \r\n  \r\n        return res; \r\n    } \r\n}",
  "status": "1",
  "language": "java",
  "user_code": "\r\n\r\n\r\n\r\n//User function Template for Java\r\n\r\n\r\nclass Solution{\r\n\tstatic boolean isFeasible(int mid, int arr[], int n, \r\n                              int k) \r\n    { \r\n        // Place first element at arr[0] position \r\n        int pos = arr[0]; \r\n  \r\n        // Initialize count of elements placed. \r\n        int elements = 1; \r\n  \r\n        // Try placing k elements with minimum \r\n        // distance mid. \r\n        for (int i = 1; i < n; i++) { \r\n            if (arr[i] - pos >= mid) { \r\n                // Place next element if its \r\n                // distance from the previously \r\n                // placed element is greater \r\n                // than current mid \r\n                pos = arr[i]; \r\n                elements++; \r\n  \r\n                // Return if all elements are \r\n                // placed successfully \r\n                if (elements == k) \r\n                    return true; \r\n            } \r\n        } \r\n        return false; \r\n    } \r\n  \r\n    // Returns largest minimum distance for \r\n    // k elements in arr[0..n-1]. If elements \r\n    // can't be placed, returns -1. \r\n    static int largestMinDist(int arr[], int n, int k) \r\n    { \r\n        // Sort the positions \r\n        Arrays.sort(arr); \r\n  \r\n        // Initialize result. \r\n        int res = -1; \r\n  \r\n        // Consider the maximum possible distance \r\n        int left = 1, right = arr[n - 1]; \r\n  \r\n        // left is initialized with 1 and not with arr[0] \r\n        // because, minimum distance between each element \r\n        // can be one and not arr[0]. consider this example: \r\n        // arr[] = {9,12} and you have to place 2 element \r\n        // then left = arr[0] will force the function to \r\n        // look the answer between range arr[0] to arr[n-1], \r\n        // i.e 9 to 12, but the answer is 3 so It is \r\n        // required that you initialize the left with 1 \r\n  \r\n        // Do binary search for largest \r\n        // minimum distance \r\n        while (left < right) { \r\n            int mid = (left + right) / 2; \r\n  \r\n            // If it is possible to place k \r\n            // elements with minimum distance mid, \r\n            // search for higher distance. \r\n            if (isFeasible(mid, arr, n, k)) { \r\n                // Change value of variable max to \r\n                // mid if all elements can be \r\n                // successfully placed \r\n                res = Math.max(res, mid); \r\n                left = mid + 1; \r\n            } \r\n  \r\n            // If not possible to place k elements, \r\n            // search for lower distance \r\n            else\r\n                right = mid; \r\n        } \r\n  \r\n        return res; \r\n    } \r\n}"
}