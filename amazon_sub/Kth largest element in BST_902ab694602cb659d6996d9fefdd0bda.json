{
  "code": "\r\n# class Node:\r\n#     def __init__(self, val):\r\n#         self.data = val\r\n#         self.left = None\r\n#         self.right = None\r\n\r\n# return the Kth largest element in the given BST rooted at 'root'\r\nclass Solution:\r\n    def kthLargest(self,root, k):\r\n        #your code here\r\n        def countNodes(root):\r\n            count = 0\r\n            curr = root\r\n    \r\n            while curr:\r\n                if not curr.left:\r\n                    count += 1\r\n                    curr = curr.right\r\n                else:\r\n                    rightMost = curr.left\r\n                    # case -2 - if left is not NULL then go to the right most node of left's\r\n                    while rightMost.right and rightMost.right != curr:\r\n                        rightMost = rightMost.right\r\n                    \r\n                    # if rightMost is NULL then their is traversal remaining for left part\r\n                    if not rightMost.right:\r\n                        rightMost.right = curr\r\n                        curr = curr.left\r\n                    else:\r\n                        rightMost.right = None\r\n                        count += 1\r\n                        curr = curr.right\r\n                \r\n            return count\r\n            \r\n        k = (countNodes(root) - k + 1)\r\n            \r\n        def kthSmallest(root, k):\r\n            count , curr= 0 , root\r\n    \r\n            while curr:\r\n                if not curr.left:\r\n                    count += 1\r\n                    if count == k:\r\n                        return curr.data\r\n                    curr = curr.right\r\n                else:\r\n                    temp = curr.left\r\n    \r\n                    while temp.right and temp.right != curr:\r\n                        temp = temp.right\r\n                    \r\n                    if not temp.right:\r\n                        temp.right = curr\r\n                        curr = curr.left\r\n                    else:\r\n                        temp.right = None\r\n                        count += 1\r\n                        if count == k:\r\n                            return curr.data\r\n                        curr = curr.right\r\n    \r\n            return -1\r\n            \r\n        return kthSmallest(root,k)\r\n\r\n\r\n#{ \r\n # Driver Code Starts\r\n#Initial Template for Python 3\r\n\r\nfrom collections import deque\r\n# Tree Node\r\nclass Node:\r\n    def __init__(self, val):\r\n        self.right = None\r\n        self.data = val\r\n        self.left = None\r\n\r\n# Function to Build Tree   \r\ndef buildTree(s):\r\n    #Corner Case\r\n    if(len(s)==0 or s[0]==\"N\"):           \r\n        return None\r\n        \r\n    # Creating list of strings from input \r\n    # string after spliting by space\r\n    ip=list(map(str,s.split()))\r\n    \r\n    # Create the root of the tree\r\n    root=Node(int(ip[0]))                     \r\n    size=0\r\n    q=deque()\r\n    \r\n    # Push the root to the queue\r\n    q.append(root)                            \r\n    size=size+1 \r\n    \r\n    # Starting from the second element\r\n    i=1                                       \r\n    while(size>0 and i<len(ip)):\r\n        # Get and remove the front of the queue\r\n        currNode=q[0]\r\n        q.popleft()\r\n        size=size-1\r\n        \r\n        # Get the current node's value from the string\r\n        currVal=ip[i]\r\n        \r\n        # If the left child is not null\r\n        if(currVal!=\"N\"):\r\n            \r\n            # Create the left child for the current node\r\n            currNode.left=Node(int(currVal))\r\n            \r\n            # Push it to the queue\r\n            q.append(currNode.left)\r\n            size=size+1\r\n        # For the right child\r\n        i=i+1\r\n        if(i>=len(ip)):\r\n            break\r\n        currVal=ip[i]\r\n        \r\n        # If the right child is not null\r\n        if(currVal!=\"N\"):\r\n            \r\n            # Create the right child for the current node\r\n            currNode.right=Node(int(currVal))\r\n            \r\n            # Push it to the queue\r\n            q.append(currNode.right)\r\n            size=size+1\r\n        i=i+1\r\n    return root\r\n    \r\nif __name__==\"__main__\":\r\n    t=int(input())\r\n    for _ in range(0,t):\r\n        s=input()\r\n        root=buildTree(s)\r\n        k = int(input())\r\n        print (Solution().kthLargest(root, k))\r\n# } Driver Code Ends",
  "status": "1",
  "language": "python3",
  "user_code": "#User function Template for python3\r\n\r\n# class Node:\r\n#     def __init__(self, val):\r\n#         self.data = val\r\n#         self.left = None\r\n#         self.right = None\r\n\r\n# return the Kth largest element in the given BST rooted at 'root'\r\nclass Solution:\r\n    def kthLargest(self,root, k):\r\n        #your code here\r\n        def countNodes(root):\r\n            count = 0\r\n            curr = root\r\n    \r\n            while curr:\r\n                if not curr.left:\r\n                    count += 1\r\n                    curr = curr.right\r\n                else:\r\n                    rightMost = curr.left\r\n                    # case -2 - if left is not NULL then go to the right most node of left's\r\n                    while rightMost.right and rightMost.right != curr:\r\n                        rightMost = rightMost.right\r\n                    \r\n                    # if rightMost is NULL then their is traversal remaining for left part\r\n                    if not rightMost.right:\r\n                        rightMost.right = curr\r\n                        curr = curr.left\r\n                    else:\r\n                        rightMost.right = None\r\n                        count += 1\r\n                        curr = curr.right\r\n                \r\n            return count\r\n            \r\n        k = (countNodes(root) - k + 1)\r\n            \r\n        def kthSmallest(root, k):\r\n            count , curr= 0 , root\r\n    \r\n            while curr:\r\n                if not curr.left:\r\n                    count += 1\r\n                    if count == k:\r\n                        return curr.data\r\n                    curr = curr.right\r\n                else:\r\n                    temp = curr.left\r\n    \r\n                    while temp.right and temp.right != curr:\r\n                        temp = temp.right\r\n                    \r\n                    if not temp.right:\r\n                        temp.right = curr\r\n                        curr = curr.left\r\n                    else:\r\n                        temp.right = None\r\n                        count += 1\r\n                        if count == k:\r\n                            return curr.data\r\n                        curr = curr.right\r\n    \r\n            return -1\r\n            \r\n        return kthSmallest(root,k)\r\n\r\n\r\n"
}