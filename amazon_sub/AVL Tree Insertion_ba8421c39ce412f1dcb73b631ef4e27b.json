{
  "code": "import java.io.*;\r\nimport java.util.*;\r\n\r\nclass pair\r\n{\r\n    int first;\r\n    boolean second;\r\n    pair(int first, boolean second)\r\n        {\r\n            this.first = first;\r\n            this.second = second;\r\n        }\r\n}\r\nclass Node\r\n{\r\n    int data, height;\r\n    Node left, right;\r\n    \r\n    Node(int x)\r\n    {\r\n        data=x;\r\n        left=right=null;\r\n        height=1;\r\n    }\r\n}\r\nclass GfG\r\n{\r\n    public static boolean isBST(Node n, int lower, int upper)\r\n    {\r\n    \tif(n==null) return true;\r\n    \tif( n.data <= lower || n.data >= upper ) return false;\r\n    \treturn isBST(n.left, lower, n.data) && isBST(n.right, n.data, upper) ;\r\n    }\r\n    \r\n    public static pair isBalanced(Node n)\r\n    {\r\n    \tif(n==null)\r\n    \t    {\r\n    \t        return new pair(0,true);\r\n    \t    }\r\n        \r\n    \tpair l = isBalanced(n.left);\r\n    \tpair r = isBalanced(n.right);\r\n    \r\n    \tif( Math.abs(l.first - r.first) > 1 ) return new pair (0,false);\r\n    \r\n    \treturn new pair( 1 + Math.max(l.first , r.first) , l.second && r.second );\r\n    }\r\n    \r\n    public static boolean isBalancedBST(Node root)\r\n    {\r\n    \tif( isBST(root, Integer.MIN_VALUE , Integer.MAX_VALUE) == false )\r\n    \t\tSystem.out.print(\"BST voilated, inorder traversal : \");\r\n    \r\n    \telse if ( isBalanced(root).second == false)\r\n    \t\tSystem.out.print(\"Unbalanced BST, inorder traversal : \");\r\n    \r\n    \telse return true;\r\n    \treturn false;\r\n    }\r\n    \r\n    public static void printInorder(Node n)\r\n    {\r\n    \tif(n==null) return;\r\n    \tprintInorder(n.left);\r\n    \tSystem.out.print(n.data + \" \");\r\n    \tprintInorder(n.right);\r\n    }\r\n\r\n\r\n    public static void main(String args[])\r\n        {\r\n            int ip[] = new int[2000];\r\n            Scanner sc = new Scanner(System.in);\r\n            int t = sc.nextInt();\r\n            while(t-->0)\r\n                {\r\n                    int n = sc.nextInt();\r\n                    for(int i = 0; i < n; i++)\r\n                        {\r\n                            ip[i] = sc.nextInt();\r\n                        }\r\n                        \r\n                    Node root = null;\r\n                    Solution obj = new Solution();\r\n                    for(int i=0; i<n; i++)\r\n                    {\r\n                        root = obj.insertToAVL( root, ip[i] );\r\n                        \r\n                        if ( isBalancedBST(root) == false )\r\n                            break;\r\n                    }\r\n                    \r\n                    printInorder(root);\r\n                    System.out.println();\r\n                    \r\n                }\r\n            \r\n                \r\n        }\r\n}\r\n// } Driver Code Ends\r\n\r\n\r\n\r\n\r\n//User function Template for Java\r\n\r\n/*\r\nclass Node\r\n{\r\n    int data;\r\n    Node left;\r\n    Node right;\r\n    int height;\r\n};\r\n*/class Solution\r\n{\r\n    public Node insertToAVL(Node root, int data)\r\n    {\r\n        if (root == null)\r\n            return new Node(data);\r\n\r\n        // Perform normal BST insertion\r\n        if (data < root.data)\r\n            root.left = insertToAVL(root.left, data);\r\n        else if (data > root.data)\r\n            root.right = insertToAVL(root.right, data);\r\n        else // Duplicate data not allowed\r\n            return root;\r\n\r\n        // Update height of the current node\r\n        root.height = 1 + Math.max(height(root.left), height(root.right));\r\n\r\n        // Get the balance factor\r\n        int balance = getBalance(root);\r\n\r\n        // Left Left Case\r\n        if (balance > 1 && data < root.left.data)\r\n            return rightRotate(root);\r\n\r\n        // Right Right Case\r\n        if (balance < -1 && data > root.right.data)\r\n            return leftRotate(root);\r\n\r\n        // Left Right Case\r\n        if (balance > 1 && data > root.left.data)\r\n        {\r\n            root.left = leftRotate(root.left);\r\n            return rightRotate(root);\r\n        }\r\n\r\n        // Right Left Case\r\n        if (balance < -1 && data < root.right.data)\r\n        {\r\n            root.right = rightRotate(root.right);\r\n            return leftRotate(root);\r\n        }\r\n\r\n        return root;\r\n    }\r\n\r\n    // Utility functions for AVL tree\r\n\r\n    int height(Node N)\r\n    {\r\n        if (N == null)\r\n            return 0;\r\n        return N.height;\r\n    }\r\n\r\n    int getBalance(Node N)\r\n    {\r\n        if (N == null)\r\n            return 0;\r\n        return height(N.left) - height(N.right);\r\n    }\r\n\r\n    Node rightRotate(Node y)\r\n    {\r\n        // Perform rotation\r\n        Node x = y.left;\r\n        Node T2 = x.right;\r\n\r\n        x.right = y;\r\n        y.left = T2;\r\n\r\n        // Update heights\r\n        y.height = 1 + Math.max(height(y.left), height(y.right));\r\n        x.height = 1 + Math.max(height(x.left), height(x.right));\r\n\r\n        // Return new root\r\n        return x;\r\n    }\r\n\r\n    Node leftRotate(Node x)\r\n    {\r\n        // Perform rotation\r\n        Node y = x.right;\r\n        Node T2 = y.left;\r\n\r\n        y.left = x;\r\n        x.right = T2;\r\n\r\n        // Update heights\r\n        x.height = 1 + Math.max(height(x.left), height(x.right));\r\n        y.height = 1 + Math.max(height(y.left), height(y.right));\r\n\r\n        // Return new root\r\n        return y;\r\n    }\r\n\r\n}    ",
  "status": "1",
  "language": "java",
  "user_code": "\r\n\r\n\r\n\r\n//User function Template for Java\r\n\r\n/*\r\nclass Node\r\n{\r\n    int data;\r\n    Node left;\r\n    Node right;\r\n    int height;\r\n};\r\n*/class Solution\r\n{\r\n    public Node insertToAVL(Node root, int data)\r\n    {\r\n        if (root == null)\r\n            return new Node(data);\r\n\r\n        // Perform normal BST insertion\r\n        if (data < root.data)\r\n            root.left = insertToAVL(root.left, data);\r\n        else if (data > root.data)\r\n            root.right = insertToAVL(root.right, data);\r\n        else // Duplicate data not allowed\r\n            return root;\r\n\r\n        // Update height of the current node\r\n        root.height = 1 + Math.max(height(root.left), height(root.right));\r\n\r\n        // Get the balance factor\r\n        int balance = getBalance(root);\r\n\r\n        // Left Left Case\r\n        if (balance > 1 && data < root.left.data)\r\n            return rightRotate(root);\r\n\r\n        // Right Right Case\r\n        if (balance < -1 && data > root.right.data)\r\n            return leftRotate(root);\r\n\r\n        // Left Right Case\r\n        if (balance > 1 && data > root.left.data)\r\n        {\r\n            root.left = leftRotate(root.left);\r\n            return rightRotate(root);\r\n        }\r\n\r\n        // Right Left Case\r\n        if (balance < -1 && data < root.right.data)\r\n        {\r\n            root.right = rightRotate(root.right);\r\n            return leftRotate(root);\r\n        }\r\n\r\n        return root;\r\n    }\r\n\r\n    // Utility functions for AVL tree\r\n\r\n    int height(Node N)\r\n    {\r\n        if (N == null)\r\n            return 0;\r\n        return N.height;\r\n    }\r\n\r\n    int getBalance(Node N)\r\n    {\r\n        if (N == null)\r\n            return 0;\r\n        return height(N.left) - height(N.right);\r\n    }\r\n\r\n    Node rightRotate(Node y)\r\n    {\r\n        // Perform rotation\r\n        Node x = y.left;\r\n        Node T2 = x.right;\r\n\r\n        x.right = y;\r\n        y.left = T2;\r\n\r\n        // Update heights\r\n        y.height = 1 + Math.max(height(y.left), height(y.right));\r\n        x.height = 1 + Math.max(height(x.left), height(x.right));\r\n\r\n        // Return new root\r\n        return x;\r\n    }\r\n\r\n    Node leftRotate(Node x)\r\n    {\r\n        // Perform rotation\r\n        Node y = x.right;\r\n        Node T2 = y.left;\r\n\r\n        y.left = x;\r\n        x.right = T2;\r\n\r\n        // Update heights\r\n        x.height = 1 + Math.max(height(x.left), height(x.right));\r\n        y.height = 1 + Math.max(height(y.left), height(y.right));\r\n\r\n        // Return new root\r\n        return y;\r\n    }\r\n\r\n}    "
}