{
  "code": "import java.util.*;\r\nimport java.lang.*;\r\nimport java.io.*;\r\nclass GFG\r\n{\r\n    public static void main(String[] args) throws IOException\r\n    {\r\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n        int T = Integer.parseInt(br.readLine().trim());\r\n        while(T-->0)\r\n        {\r\n            int n = Integer.parseInt(br.readLine().trim());\r\n            String[] wordList = new String[n];\r\n            for(int i = 0; i < n; i++){\r\n                wordList[i] = br.readLine().trim();\r\n            }\r\n            String startWord, targetWord;\r\n            startWord = br.readLine().trim();\r\n            targetWord = br.readLine().trim();\r\n            Solution obj = new Solution();\r\n            int ans = obj.wordLadderLength(startWord, targetWord, wordList);\r\n            System.out.println(ans);\r\n       }\r\n    }\r\n}\r\n\r\n// } Driver Code Ends\r\n\r\n\r\n// import java.util.HashSet;\r\n// import java.util.LinkedList;\r\n// import java.util.Queue;\r\n// import java.util.Set;\r\n\r\nclass Solution {\r\n    public int wordLadderLength(String startWord, String targetWord, String[] wordList) {\r\n        Set<String> wordSet = new HashSet<>();\r\n        for (String word : wordList) {\r\n            wordSet.add(word);\r\n        }\r\n\r\n        if (!wordSet.contains(targetWord)) {\r\n            return 0; // targetWord is not in wordList, transformation not possible\r\n        }\r\n\r\n        Queue<String> queue = new LinkedList<>();\r\n        queue.offer(startWord);\r\n        int ladderLength = 1;\r\n\r\n        while (!queue.isEmpty()) {\r\n            int currentSize = queue.size();\r\n\r\n            for (int i = 0; i < currentSize; i++) {\r\n                String currentWord = queue.poll();\r\n\r\n                char[] charArray = currentWord.toCharArray();\r\n                for (int j = 0; j < charArray.length; j++) {\r\n                    char originalChar = charArray[j];\r\n\r\n                    for (char c = 'a'; c <= 'z'; c++) {\r\n                        if (c == originalChar) {\r\n                            continue;\r\n                        }\r\n\r\n                        charArray[j] = c;\r\n                        String transformedWord = new String(charArray);\r\n\r\n                        if (transformedWord.equals(targetWord)) {\r\n                            return ladderLength + 1; // Transformation completed\r\n                        }\r\n\r\n                        if (wordSet.contains(transformedWord)) {\r\n                            queue.offer(transformedWord);\r\n                            wordSet.remove(transformedWord); // Mark as visited\r\n                        }\r\n                    }\r\n\r\n                    charArray[j] = originalChar; // Restore the original character\r\n                }\r\n            }\r\n\r\n            ladderLength++;\r\n        }\r\n\r\n        return 0; // No possible transformation\r\n    }\r\n}\r\n",
  "status": "1",
  "language": "java",
  "user_code": "\r\n\r\n// import java.util.HashSet;\r\n// import java.util.LinkedList;\r\n// import java.util.Queue;\r\n// import java.util.Set;\r\n\r\nclass Solution {\r\n    public int wordLadderLength(String startWord, String targetWord, String[] wordList) {\r\n        Set<String> wordSet = new HashSet<>();\r\n        for (String word : wordList) {\r\n            wordSet.add(word);\r\n        }\r\n\r\n        if (!wordSet.contains(targetWord)) {\r\n            return 0; // targetWord is not in wordList, transformation not possible\r\n        }\r\n\r\n        Queue<String> queue = new LinkedList<>();\r\n        queue.offer(startWord);\r\n        int ladderLength = 1;\r\n\r\n        while (!queue.isEmpty()) {\r\n            int currentSize = queue.size();\r\n\r\n            for (int i = 0; i < currentSize; i++) {\r\n                String currentWord = queue.poll();\r\n\r\n                char[] charArray = currentWord.toCharArray();\r\n                for (int j = 0; j < charArray.length; j++) {\r\n                    char originalChar = charArray[j];\r\n\r\n                    for (char c = 'a'; c <= 'z'; c++) {\r\n                        if (c == originalChar) {\r\n                            continue;\r\n                        }\r\n\r\n                        charArray[j] = c;\r\n                        String transformedWord = new String(charArray);\r\n\r\n                        if (transformedWord.equals(targetWord)) {\r\n                            return ladderLength + 1; // Transformation completed\r\n                        }\r\n\r\n                        if (wordSet.contains(transformedWord)) {\r\n                            queue.offer(transformedWord);\r\n                            wordSet.remove(transformedWord); // Mark as visited\r\n                        }\r\n                    }\r\n\r\n                    charArray[j] = originalChar; // Restore the original character\r\n                }\r\n            }\r\n\r\n            ladderLength++;\r\n        }\r\n\r\n        return 0; // No possible transformation\r\n    }\r\n}\r\n"
}