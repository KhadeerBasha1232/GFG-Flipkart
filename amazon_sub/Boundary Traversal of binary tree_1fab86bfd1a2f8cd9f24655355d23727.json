{
  "code": "import java.io.*;\r\nimport java.util.*;\r\n\r\nclass Node  \r\n{ \r\n    int data; \r\n    Node left, right; \r\n   \r\n    public Node(int d)  \r\n    { \r\n        data = d; \r\n        left = right = null; \r\n    } \r\n}\r\n\r\nclass GFG\r\n{\r\n    static Node buildTree(String str)\r\n    {\r\n        // Corner Case\r\n        if(str.length() == 0 || str.equals('N'))\r\n            return null;\r\n        String[] s = str.split(\" \");\r\n        \r\n        Node root = new Node(Integer.parseInt(s[0]));\r\n        Queue <Node> q = new LinkedList<Node>();\r\n        q.add(root);\r\n        \r\n        // Starting from the second element\r\n        int i = 1;\r\n        while(!q.isEmpty() && i < s.length)\r\n        {\r\n              // Get and remove the front of the queue\r\n              Node currNode = q.remove();\r\n        \r\n              // Get the current node's value from the string\r\n              String currVal = s[i];\r\n        \r\n              // If the left child is not null\r\n              if(!currVal.equals(\"N\")) \r\n              {\r\n        \r\n                  // Create the left child for the current node\r\n                  currNode.left = new Node(Integer.parseInt(currVal));\r\n        \r\n                  // Push it to the queue\r\n                  q.add(currNode.left);\r\n              }\r\n        \r\n              // For the right child\r\n              i++;\r\n              if(i >= s.length)\r\n                  break;\r\n              currVal = s[i];\r\n        \r\n              // If the right child is not null\r\n              if(!currVal.equals(\"N\")) \r\n              {\r\n        \r\n                  // Create the right child for the current node\r\n                  currNode.right = new Node(Integer.parseInt(currVal));\r\n        \r\n                  // Push it to the queue\r\n                  q.add(currNode.right);\r\n              }\r\n              \r\n              i++;\r\n        }\r\n    \r\n        return root;\r\n    }\r\n    \r\n    public static void main(String args[]) throws IOException {\r\n    \r\n       BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n        int t = Integer.parseInt(br.readLine().trim());\r\n        while(t>0)\r\n        {\r\n            String s = br.readLine();\r\n            Node root = buildTree(s);\r\n            \r\n            Solution T = new Solution();\r\n            \r\n            ArrayList <Integer> res = T.boundary(root);\r\n            for (Integer num : res) System.out.print (num + \" \");\r\n            System.out.println();\r\n            t--;\r\n        }\r\n    }\r\n}\r\n\r\n// } Driver Code Ends\r\n\r\n\r\n//User function Template for Java\r\n\r\n// class Node  \r\n// { \r\n//     int data; \r\n//     Node left, right; \r\n   \r\n//     public Node(int d)  \r\n//     { \r\n//         data = d; \r\n//         left = right = null; \r\n//     } \r\n// }\r\n\r\nclass Solution\r\n{\r\n    public boolean isLeaf(Node root){\r\n        return root.left == null && root.right == null;\r\n    }\r\n    \r\n    public void leftBoundary(Node root, ArrayList<Integer> list){\r\n        Node curr = root.left;\r\n        \r\n        while(curr != null){\r\n            if(!isLeaf(curr)){\r\n                list.add(curr.data);\r\n            }\r\n            \r\n            if(curr.left != null){\r\n                curr = curr.left;\r\n            }\r\n            else curr = curr.right;\r\n        }\r\n        \r\n    }\r\n    \r\n    public void leaves(Node root, ArrayList<Integer> list){\r\n        if(isLeaf(root)) {\r\n            list.add(root.data);\r\n            return;\r\n        }\r\n        \r\n        if(root.left != null) leaves(root.left, list);\r\n        if(root.right != null) leaves(root.right, list);\r\n    }\r\n    \r\n    public void rightBoundary(Node root, ArrayList<Integer> list){\r\n        Node curr = root.right;\r\n        ArrayList<Integer> temp = new ArrayList<>();\r\n        \r\n        while(curr != null){\r\n            if(!isLeaf(curr)) temp.add(curr.data);\r\n            \r\n            if(curr.right != null) curr = curr.right;\r\n            else curr = curr.left;\r\n        }\r\n        \r\n        for(int i = temp.size()-1; i >= 0 ; i--){\r\n            list.add(temp.get(i));\r\n        }\r\n        \r\n    }\r\n\tArrayList <Integer> boundary(Node node)\r\n\t{\r\n\t    ArrayList<Integer> list = new ArrayList<>();\r\n\t    \r\n\t    if(isLeaf(node)){\r\n\t        list.add(node.data);\r\n\t        return list;\r\n\t    }\r\n\t    \r\n\t    if(!isLeaf(node)){\r\n\t        list.add(node.data);\r\n\t    }\r\n\t    \r\n\t    leftBoundary(node, list);\r\n\t    leaves(node, list);\r\n\t    rightBoundary(node, list);\r\n\t    \r\n\t    return list;\r\n\t}\r\n}\r\n",
  "status": "1",
  "language": "java",
  "user_code": "\r\n\r\n//User function Template for Java\r\n\r\n// class Node  \r\n// { \r\n//     int data; \r\n//     Node left, right; \r\n   \r\n//     public Node(int d)  \r\n//     { \r\n//         data = d; \r\n//         left = right = null; \r\n//     } \r\n// }\r\n\r\nclass Solution\r\n{\r\n    public boolean isLeaf(Node root){\r\n        return root.left == null && root.right == null;\r\n    }\r\n    \r\n    public void leftBoundary(Node root, ArrayList<Integer> list){\r\n        Node curr = root.left;\r\n        \r\n        while(curr != null){\r\n            if(!isLeaf(curr)){\r\n                list.add(curr.data);\r\n            }\r\n            \r\n            if(curr.left != null){\r\n                curr = curr.left;\r\n            }\r\n            else curr = curr.right;\r\n        }\r\n        \r\n    }\r\n    \r\n    public void leaves(Node root, ArrayList<Integer> list){\r\n        if(isLeaf(root)) {\r\n            list.add(root.data);\r\n            return;\r\n        }\r\n        \r\n        if(root.left != null) leaves(root.left, list);\r\n        if(root.right != null) leaves(root.right, list);\r\n    }\r\n    \r\n    public void rightBoundary(Node root, ArrayList<Integer> list){\r\n        Node curr = root.right;\r\n        ArrayList<Integer> temp = new ArrayList<>();\r\n        \r\n        while(curr != null){\r\n            if(!isLeaf(curr)) temp.add(curr.data);\r\n            \r\n            if(curr.right != null) curr = curr.right;\r\n            else curr = curr.left;\r\n        }\r\n        \r\n        for(int i = temp.size()-1; i >= 0 ; i--){\r\n            list.add(temp.get(i));\r\n        }\r\n        \r\n    }\r\n\tArrayList <Integer> boundary(Node node)\r\n\t{\r\n\t    ArrayList<Integer> list = new ArrayList<>();\r\n\t    \r\n\t    if(isLeaf(node)){\r\n\t        list.add(node.data);\r\n\t        return list;\r\n\t    }\r\n\t    \r\n\t    if(!isLeaf(node)){\r\n\t        list.add(node.data);\r\n\t    }\r\n\t    \r\n\t    leftBoundary(node, list);\r\n\t    leaves(node, list);\r\n\t    rightBoundary(node, list);\r\n\t    \r\n\t    return list;\r\n\t}\r\n}\r\n"
}