{
  "code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\n// } Driver Code Ends\r\n\r\nclass Solution\r\n{\r\n\tpublic:\r\n\r\n    // DSU data structure \r\n    // path compression + rank by union \r\n    class DSU { \r\n    \tint* parent; \r\n    \tint* rank; \r\n    \r\n    public: \r\n    \tDSU(int n) \r\n    \t{ \r\n    \t\tparent = new int[n]; \r\n    \t\trank = new int[n]; \r\n    \r\n    \t\tfor (int i = 0; i < n; i++) { \r\n    \t\t\tparent[i] = -1; \r\n    \t\t\trank[i] = 1; \r\n    \t\t} \r\n    \t} \r\n    \r\n    \t// Find function \r\n    \tint find(int i) \r\n    \t{ \r\n    \t\tif (parent[i] == -1) \r\n    \t\t\treturn i; \r\n    \r\n    \t\treturn parent[i] = find(parent[i]); \r\n    \t} \r\n    \r\n    \t// Union function \r\n    \tvoid unite(int x, int y) \r\n    \t{ \r\n    \t\tint s1 = find(x); \r\n    \t\tint s2 = find(y); \r\n    \r\n    \t\tif (s1 != s2) { \r\n    \t\t\tif (rank[s1] < rank[s2]) { \r\n    \t\t\t\tparent[s1] = s2; \r\n    \t\t\t} \r\n    \t\t\telse if (rank[s1] > rank[s2]) { \r\n    \t\t\t\tparent[s2] = s1; \r\n    \t\t\t} \r\n    \t\t\telse { \r\n    \t\t\t\tparent[s2] = s1; \r\n    \t\t\t\trank[s1] += 1; \r\n    \t\t\t} \r\n    \t\t} \r\n    \t} \r\n    }; \r\n\r\n\r\n\t//Function to find sum of weights of edges of the Minimum Spanning Tree.\r\n    int spanningTree(int V, vector<vector<int>> adj[]) {\r\n  \t\t// Sort all edges \r\n\t    vector<vector<int>> edgelist;\t\r\n\t\tfor(int vertex_u = 0; vertex_u < V; vertex_u++){\r\n\t\t    for(auto edge: adj[vertex_u]){\r\n\t\t        edgelist.push_back({edge[1], vertex_u , edge[0]});\r\n\t\t    }\r\n\t\t}\r\n\t\tsort(edgelist.begin(), edgelist.end()); \r\n\r\n\t\t// Initialize the DSU \r\n\t\tDSU s(V); \r\n\t\tint ans = 0; \r\n\t\tfor (auto edge : edgelist) { \r\n\t\t\tint w = edge[0]; \r\n\t\t\tint x = edge[1]; \r\n\t\t\tint y = edge[2]; \r\n\r\n\t\t\t// Take this edge in MST if it does \r\n\t\t\t// not forms a cycle \r\n\t\t\tif (s.find(x) != s.find(y)) { \r\n\t\t\t\ts.unite(x, y); \r\n\t\t\t\tans += w; \r\n\t\t\t} \r\n\t\t}\r\n    \t\r\n    \treturn ans; // Return the sum of edge weights of the Minimum Spanning Tree\r\n    }\r\n    \r\n};\r\n\r\n//{ Driver Code Starts.\r\n\r\n\r\nint main()\r\n{\r\n    int t;\r\n    cin >> t;\r\n    while (t--) {\r\n        int V, E;\r\n        cin >> V >> E;\r\n        vector<vector<int>> adj[V];\r\n        int i=0;\r\n        while (i++<E) {\r\n            int u, v, w;\r\n            cin >> u >> v >> w;\r\n            vector<int> t1,t2;\r\n            t1.push_back(v);\r\n            t1.push_back(w);\r\n            adj[u].push_back(t1);\r\n            t2.push_back(u);\r\n            t2.push_back(w);\r\n            adj[v].push_back(t2);\r\n        }\r\n        \r\n        Solution obj;\r\n    \tcout << obj.spanningTree(V, adj) << \"\\n\";\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n\r\n// } Driver Code Ends",
  "status": "1",
  "language": "cpp",
  "user_code": "\r\nclass Solution\r\n{\r\n\tpublic:\r\n\r\n    // DSU data structure \r\n    // path compression + rank by union \r\n    class DSU { \r\n    \tint* parent; \r\n    \tint* rank; \r\n    \r\n    public: \r\n    \tDSU(int n) \r\n    \t{ \r\n    \t\tparent = new int[n]; \r\n    \t\trank = new int[n]; \r\n    \r\n    \t\tfor (int i = 0; i < n; i++) { \r\n    \t\t\tparent[i] = -1; \r\n    \t\t\trank[i] = 1; \r\n    \t\t} \r\n    \t} \r\n    \r\n    \t// Find function \r\n    \tint find(int i) \r\n    \t{ \r\n    \t\tif (parent[i] == -1) \r\n    \t\t\treturn i; \r\n    \r\n    \t\treturn parent[i] = find(parent[i]); \r\n    \t} \r\n    \r\n    \t// Union function \r\n    \tvoid unite(int x, int y) \r\n    \t{ \r\n    \t\tint s1 = find(x); \r\n    \t\tint s2 = find(y); \r\n    \r\n    \t\tif (s1 != s2) { \r\n    \t\t\tif (rank[s1] < rank[s2]) { \r\n    \t\t\t\tparent[s1] = s2; \r\n    \t\t\t} \r\n    \t\t\telse if (rank[s1] > rank[s2]) { \r\n    \t\t\t\tparent[s2] = s1; \r\n    \t\t\t} \r\n    \t\t\telse { \r\n    \t\t\t\tparent[s2] = s1; \r\n    \t\t\t\trank[s1] += 1; \r\n    \t\t\t} \r\n    \t\t} \r\n    \t} \r\n    }; \r\n\r\n\r\n\t//Function to find sum of weights of edges of the Minimum Spanning Tree.\r\n    int spanningTree(int V, vector<vector<int>> adj[]) {\r\n  \t\t// Sort all edges \r\n\t    vector<vector<int>> edgelist;\t\r\n\t\tfor(int vertex_u = 0; vertex_u < V; vertex_u++){\r\n\t\t    for(auto edge: adj[vertex_u]){\r\n\t\t        edgelist.push_back({edge[1], vertex_u , edge[0]});\r\n\t\t    }\r\n\t\t}\r\n\t\tsort(edgelist.begin(), edgelist.end()); \r\n\r\n\t\t// Initialize the DSU \r\n\t\tDSU s(V); \r\n\t\tint ans = 0; \r\n\t\tfor (auto edge : edgelist) { \r\n\t\t\tint w = edge[0]; \r\n\t\t\tint x = edge[1]; \r\n\t\t\tint y = edge[2]; \r\n\r\n\t\t\t// Take this edge in MST if it does \r\n\t\t\t// not forms a cycle \r\n\t\t\tif (s.find(x) != s.find(y)) { \r\n\t\t\t\ts.unite(x, y); \r\n\t\t\t\tans += w; \r\n\t\t\t} \r\n\t\t}\r\n    \t\r\n    \treturn ans; // Return the sum of edge weights of the Minimum Spanning Tree\r\n    }\r\n    \r\n};\r\n"
}