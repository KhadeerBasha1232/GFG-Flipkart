{
  "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n/* A binary tree node has data, pointer to left child\r\n   and a pointer to right child */\r\nstruct Node\r\n{\r\n\tint data;\r\n\tstruct Node *left;\r\n\tstruct Node *right;\r\n\tstruct Node *random;\r\n\t\r\n\tNode(int x){\r\n\t    data = x;\r\n\t    left = NULL;\r\n\t    right = NULL;\r\n\t    random = NULL;\r\n\t}\r\n};\r\nint checkcloned(Node* a, Node *b)\r\n{\r\n\tif ((a == NULL and b == NULL))\r\n\t\treturn 1;\r\n\r\n\tif (a != NULL && b != NULL)\r\n\t{\r\n\t\tint t = (a->data == b->data && checkcloned(a->left, b->left) && checkcloned(a->right, b->right));\r\n\r\n\t\tif (a->random != NULL && b->random != NULL)\r\n\t\t\treturn (t && a->random->data == b->random->data);\r\n\t\tif (a->random == b->random)\r\n\t\t\treturn t;\r\n\r\n\t\treturn 0;\r\n\t}\r\n\r\n\treturn 0;\r\n\r\n}\r\n\r\nvoid inorder(Node *root)\r\n{\r\n    if (root == NULL)\r\n       return;\r\n    inorder(root->left);\r\n    cout << root->data << \" \";\r\n    inorder(root->right);\r\n}\r\n\r\n// } Driver Code Ends\r\n/* A binary tree node has data, pointer to left child\r\n   and a pointer to right child \r\nstruct Node\r\n{\r\n    int data;\r\n    Node* left;\r\n    Node* right;\r\n    Node *random;\r\n};\r\n*/\r\n\r\nclass Solution{\r\n  public:\r\n    /* The function should clone the passed tree and return \r\n       root of the cloned tree */\r\n    Node* cloneTree(Node* tree)\r\n    {\r\n       //Your code here\r\n       Node*root=tree;\r\n       queue<pair<Node*,Node*>> q;\r\n        Node*temp=new Node(tree->data);\r\n       q.push({root,temp});\r\n       while(!q.empty())\r\n       {\r\n           int n=q.size();\r\n           for(int i=0;i<n;i++)\r\n           {\r\n               Node*x=q.front().first;\r\n               Node*y=q.front().second;\r\n               q.pop();\r\n               if(x->random)\r\n               {\r\n                       Node*newnode=new Node(x->random->data);\r\n                       y->random=newnode;\r\n               }\r\n               \r\n               if(x->left!=NULL)\r\n               {\r\n                   Node*newnode=new Node(x->left->data);\r\n                   y->left=newnode;\r\n                   q.push({x->left,y->left});\r\n               }\r\n               if(  x->right!=NULL){\r\n                   Node*newnode=new Node(x->right->data);\r\n                   y->right=newnode;\r\n                   q.push({x->right,newnode});\r\n               }\r\n           }\r\n       }\r\n       return temp;\r\n    }\r\n};\r\n\r\n\r\n//{ Driver Code Starts.\r\n/* Driver program to test size function*/\r\nint main()\r\n{\r\n  int t;\r\n  scanf(\"%d\\n\", &t);\r\n  while (t--)\r\n  {\r\n     map<int, Node*> m;\r\n     int n;\r\n     scanf(\"%d\",&n);\r\n     struct Node *root = NULL;\r\n     struct Node *child;\r\n     while (n--)\r\n     {\r\n        Node *parent;\r\n        char lr;\r\n        int n1, n2;\r\n        scanf(\"%d %d %c\", &n1, &n2, &lr);\r\n\r\n        if (m.find(n1) == m.end())\r\n        {\r\n           parent = new Node(n1);\r\n           m[n1] = parent;\r\n           if (root == NULL)\r\n             root = parent;\r\n        }\r\n        else\r\n           parent = m[n1];\r\n\r\n        child = new Node(n2);\r\n        if (lr == 'L'){\r\n          parent->left = child;\r\n           m[n2]  = child;\r\n        }\r\n        else if(lr=='R'){\r\n          parent->right = child;\r\n           m[n2]  = child;\r\n        }\r\n        else{\r\n          parent->random = m[n2];\r\n        }\r\n\r\n\r\n     }\r\n     Solution obj;\r\n     Node *t = obj.cloneTree(root);\r\n     if(t==root)\r\n        cout<<0<<endl;\r\n     else\r\n     cout<<checkcloned(root,t);\r\n     cout<<\"\\n\";\r\n  }\r\n  return 0;\r\n}\r\n\r\n\r\n// } Driver Code Ends",
  "status": "1",
  "language": "cpp",
  "user_code": "/* A binary tree node has data, pointer to left child\r\n   and a pointer to right child \r\nstruct Node\r\n{\r\n    int data;\r\n    Node* left;\r\n    Node* right;\r\n    Node *random;\r\n};\r\n*/\r\n\r\nclass Solution{\r\n  public:\r\n    /* The function should clone the passed tree and return \r\n       root of the cloned tree */\r\n    Node* cloneTree(Node* tree)\r\n    {\r\n       //Your code here\r\n       Node*root=tree;\r\n       queue<pair<Node*,Node*>> q;\r\n        Node*temp=new Node(tree->data);\r\n       q.push({root,temp});\r\n       while(!q.empty())\r\n       {\r\n           int n=q.size();\r\n           for(int i=0;i<n;i++)\r\n           {\r\n               Node*x=q.front().first;\r\n               Node*y=q.front().second;\r\n               q.pop();\r\n               if(x->random)\r\n               {\r\n                       Node*newnode=new Node(x->random->data);\r\n                       y->random=newnode;\r\n               }\r\n               \r\n               if(x->left!=NULL)\r\n               {\r\n                   Node*newnode=new Node(x->left->data);\r\n                   y->left=newnode;\r\n                   q.push({x->left,y->left});\r\n               }\r\n               if(  x->right!=NULL){\r\n                   Node*newnode=new Node(x->right->data);\r\n                   y->right=newnode;\r\n                   q.push({x->right,newnode});\r\n               }\r\n           }\r\n       }\r\n       return temp;\r\n    }\r\n};\r\n\r\n"
}