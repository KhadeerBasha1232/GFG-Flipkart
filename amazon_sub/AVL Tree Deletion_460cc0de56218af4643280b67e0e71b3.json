{
  "code": "//\r\n\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nstruct Node\r\n{\r\n\tint data, height;\r\n\tNode *left, *right;\r\n\tNode(int x)\r\n\t{\r\n\t\tdata = x;\r\n\t\theight = 1;\r\n\t\tleft = right = NULL;\r\n\t}\r\n};\r\n\r\nint setHeights(Node* n)\r\n{\r\n\tif(!n) return 0;\r\n\tn->height = 1 + max( setHeights(n->left) , setHeights(n->right) );\r\n\treturn n->height;\r\n}\r\n\r\nNode* buildTree(string str)\r\n{   \r\n    // Corner Case\r\n    if(str.length() == 0 || str[0] == 'N')\r\n            return NULL;\r\n    \r\n    // Creating vector of strings from input \r\n    // string after spliting by space\r\n    vector<string> ip;\r\n    \r\n    istringstream iss(str);\r\n    for(string str; iss >> str; )\r\n        ip.push_back(str);\r\n        \r\n    // Create the root of the tree\r\n    Node* root = new Node(stoi(ip[0]));\r\n        \r\n    // Push the root to the queue\r\n    queue<Node*> queue;\r\n    queue.push(root);\r\n        \r\n    // Starting from the second element\r\n    int i = 1;\r\n    while(!queue.empty() && i < ip.size()) {\r\n            \r\n        // Get and remove the front of the queue\r\n        Node* currNode = queue.front();\r\n        queue.pop();\r\n            \r\n        // Get the current node's value from the string\r\n        string currVal = ip[i];\r\n            \r\n        // If the left child is not null\r\n        if(currVal != \"N\") {\r\n                \r\n            // Create the left child for the current node\r\n            currNode->left = new Node(stoi(currVal));\r\n                \r\n            // Push it to the queue\r\n            queue.push(currNode->left);\r\n        }\r\n            \r\n        // For the right child\r\n        i++;\r\n        if(i >= ip.size())\r\n            break;\r\n        currVal = ip[i];\r\n            \r\n        // If the right child is not null\r\n        if(currVal != \"N\") {\r\n                \r\n            // Create the right child for the current node\r\n            currNode->right = new Node(stoi(currVal));\r\n                \r\n            // Push it to the queue\r\n            queue.push(currNode->right);\r\n        }\r\n        i++;\r\n    }\r\n    \r\n    setHeights(root);\r\n    return root;\r\n}\r\n\r\nbool isBST(Node *n, int lower, int upper)\r\n{\r\n\tif(!n) return 1;\r\n\tif( n->data <= lower || n->data >= upper ) return 0;\r\n\treturn isBST(n->left, lower, n->data) && isBST(n->right, n->data, upper) ;\r\n}\r\n\r\npair<int,bool> isBalanced(Node* n)\r\n{\r\n\tif(!n) return pair<int,bool> (0,1);\r\n\r\n\tpair<int,bool> l = isBalanced(n->left);\r\n\tpair<int,bool> r = isBalanced(n->right);\r\n\r\n\tif( abs(l.first - r.first) > 1 ) return pair<int,bool> (0,0);\r\n\r\n\treturn pair<int,bool> ( 1 + max(l.first , r.first) , l.second && r.second );\r\n}\r\n\r\nbool isBalancedBST(Node* root)\r\n{\r\n\tif( !isBST(root, INT_MIN, INT_MAX) )\r\n\t\tcout<< \"BST voilated, inorder traversal : \";\r\n\r\n\telse if ( ! isBalanced(root).second )\r\n\t\tcout<< \"Unbalanced BST, inorder traversal : \";\r\n\r\n\telse return 1;\r\n\treturn 0;\r\n}\r\n\r\nvoid printInorder(Node* n)\r\n{\r\n\tif(!n) return;\r\n\tprintInorder(n->left);\r\n\tcout<< n->data << \" \";\r\n\tprintInorder(n->right);\r\n}\r\n\r\nstruct Node* deleteNode(struct Node* root, int data);\r\n\r\nint main()\r\n{\r\n\tint t;\r\n\tcin>>t;\r\n\tgetchar();\r\n\r\n\twhile(t--)\r\n\t{\r\n\t\tstring s;\r\n\t\tgetline(cin,s);\r\n\t\tNode* root = buildTree(s);\r\n        \r\n\t\tint n;\r\n\t\tcin>> n;\r\n\t\tint ip[n];\r\n\t\tfor(int i=0; i<n; i++)\r\n\t\t\tcin>> ip[i];\r\n        \r\n\t\tfor(int i=0; i<n; i++)\r\n\t\t{\r\n\t\t\troot = deleteNode(root, ip[i]);\r\n\t\t\t\r\n\t\t\tif( !isBalancedBST(root) )\r\n\t\t\t\tbreak;\r\n\t\t}\r\n        \r\n\t\tif(root==NULL)\r\n\t\t\tcout<<\"null\";\r\n\t\telse\r\n\t\t\tprintInorder(root);\r\n\t\tcout<< endl;\r\n        \r\n\t\tgetline(cin,s); // to deal with newline char\r\n\t}\r\n\treturn 1;\r\n}\r\n\r\n// } Driver Code Ends\r\n\r\n\r\n/* Node is as follows:\r\n\r\nstruct Node\r\n{\r\n\tint data, height;\r\n\tNode *left, *right;\r\n\tNode(int x)\r\n\t{\r\n\t\tdata = x;\r\n\t\theight = 1;\r\n\t\tleft = right = NULL;\r\n\t}\r\n};\r\n\r\n*/\r\nint height(Node* N){\r\n    if(N==NULL){\r\n        return 0;\r\n    }\r\n    return N->height;\r\n}\r\n\r\nint getBalance(Node* N){\r\n    if(N==NULL){\r\n        return 0;\r\n    }\r\n    return height(N->left)-height(N->right);\r\n}\r\n\r\nNode* leftRotation(Node* x){\r\n    Node* y = x->right;\r\n    Node* T2 = y->left;\r\n    \r\n    y->left = x;\r\n    x->right = T2;\r\n    \r\n    x->height = 1+max(height(x->left),height(x->right));\r\n    y->height = 1+max(height(y->left),height(y->right));\r\n    \r\n    return y;\r\n}\r\n\r\nNode* rightRotation(Node* x){\r\n    Node* y = x->left;\r\n    Node* T2 = y->right;\r\n    \r\n    y->right = x;\r\n    x->left = T2;\r\n    \r\n    x->height = 1+max(height(x->left),height(x->right));\r\n    y->height = 1+max(height(y->left),height(y->right));\r\n    \r\n    return y;\r\n}\r\n\r\nNode* getSuccessor(Node* curr){\r\n    curr = curr->right;\r\n    while(curr!=NULL && curr->left!=NULL){\r\n        curr = curr->left;\r\n    }\r\n    return curr;\r\n}\r\nNode* deleteNode(Node* root, int data)\r\n{\r\n    //add code here,\r\n      if(root==NULL){\r\n        return root;\r\n    }else if(data > root->data){\r\n        root->right = deleteNode(root->right,data);\r\n    }else if(data < root->data){\r\n        root->left = deleteNode(root->left,data);\r\n    }else{\r\n        if(root->left==NULL || root->right==NULL){\r\n            Node* temp = root->left ? root->left : root->right;\r\n            if(temp==NULL){\r\n                temp = root;\r\n                root = NULL;\r\n            }else{\r\n                *root = *temp;    \r\n            }\r\n            delete temp;\r\n        }else{\r\n            Node* succ = getSuccessor(root);\r\n            root->data = succ->data;\r\n            root->right = deleteNode(root->right,succ->data);\r\n        }\r\n    }\r\n    \r\n    if(root==NULL){\r\n        return root;\r\n    }\r\n    \r\n    root->height = 1+max(height(root->left),height(root->right));\r\n    \r\n    int balance = getBalance(root);\r\n    \r\n    if(balance>1 && getBalance(root->left)>=0){\r\n        return rightRotation(root);\r\n    }\r\n    if(balance<-1 && getBalance(root->right)<=0){\r\n        return leftRotation(root);\r\n    }\r\n    if(balance>1 && getBalance(root->left)<0){\r\n        root->left = leftRotation(root->left);\r\n        return rightRotation(root);\r\n    }\r\n    if(balance<-1 && getBalance(root->right)>0){\r\n        root->right= rightRotation(root->right);\r\n        return leftRotation(root);\r\n    }\r\n    return root;\r\n}",
  "status": "1",
  "language": "cpp",
  "user_code": "\r\n\r\n/* Node is as follows:\r\n\r\nstruct Node\r\n{\r\n\tint data, height;\r\n\tNode *left, *right;\r\n\tNode(int x)\r\n\t{\r\n\t\tdata = x;\r\n\t\theight = 1;\r\n\t\tleft = right = NULL;\r\n\t}\r\n};\r\n\r\n*/\r\nint height(Node* N){\r\n    if(N==NULL){\r\n        return 0;\r\n    }\r\n    return N->height;\r\n}\r\n\r\nint getBalance(Node* N){\r\n    if(N==NULL){\r\n        return 0;\r\n    }\r\n    return height(N->left)-height(N->right);\r\n}\r\n\r\nNode* leftRotation(Node* x){\r\n    Node* y = x->right;\r\n    Node* T2 = y->left;\r\n    \r\n    y->left = x;\r\n    x->right = T2;\r\n    \r\n    x->height = 1+max(height(x->left),height(x->right));\r\n    y->height = 1+max(height(y->left),height(y->right));\r\n    \r\n    return y;\r\n}\r\n\r\nNode* rightRotation(Node* x){\r\n    Node* y = x->left;\r\n    Node* T2 = y->right;\r\n    \r\n    y->right = x;\r\n    x->left = T2;\r\n    \r\n    x->height = 1+max(height(x->left),height(x->right));\r\n    y->height = 1+max(height(y->left),height(y->right));\r\n    \r\n    return y;\r\n}\r\n\r\nNode* getSuccessor(Node* curr){\r\n    curr = curr->right;\r\n    while(curr!=NULL && curr->left!=NULL){\r\n        curr = curr->left;\r\n    }\r\n    return curr;\r\n}\r\nNode* deleteNode(Node* root, int data)\r\n{\r\n    //add code here,\r\n      if(root==NULL){\r\n        return root;\r\n    }else if(data > root->data){\r\n        root->right = deleteNode(root->right,data);\r\n    }else if(data < root->data){\r\n        root->left = deleteNode(root->left,data);\r\n    }else{\r\n        if(root->left==NULL || root->right==NULL){\r\n            Node* temp = root->left ? root->left : root->right;\r\n            if(temp==NULL){\r\n                temp = root;\r\n                root = NULL;\r\n            }else{\r\n                *root = *temp;    \r\n            }\r\n            delete temp;\r\n        }else{\r\n            Node* succ = getSuccessor(root);\r\n            root->data = succ->data;\r\n            root->right = deleteNode(root->right,succ->data);\r\n        }\r\n    }\r\n    \r\n    if(root==NULL){\r\n        return root;\r\n    }\r\n    \r\n    root->height = 1+max(height(root->left),height(root->right));\r\n    \r\n    int balance = getBalance(root);\r\n    \r\n    if(balance>1 && getBalance(root->left)>=0){\r\n        return rightRotation(root);\r\n    }\r\n    if(balance<-1 && getBalance(root->right)<=0){\r\n        return leftRotation(root);\r\n    }\r\n    if(balance>1 && getBalance(root->left)<0){\r\n        root->left = leftRotation(root->left);\r\n        return rightRotation(root);\r\n    }\r\n    if(balance<-1 && getBalance(root->right)>0){\r\n        root->right= rightRotation(root->right);\r\n        return leftRotation(root);\r\n    }\r\n    return root;\r\n}"
}