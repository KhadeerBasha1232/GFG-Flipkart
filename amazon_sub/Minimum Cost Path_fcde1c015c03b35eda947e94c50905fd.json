{
  "code": "import java.util.*;\r\nimport java.lang.*;\r\nimport java.io.*;\r\nclass GFG\r\n{\r\n    public static void main(String[] args) throws IOException\r\n    {\r\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n        int T = Integer.parseInt(br.readLine().trim());\r\n        while(T-->0)\r\n        {\r\n            String[] s = br.readLine().trim().split(\" \");\r\n            int n = Integer.parseInt(s[0]);\r\n            int[][] grid = new int[n][n];\r\n            for(int i = 0; i < n; i++){\r\n                String[] S = br.readLine().trim().split(\" \");\r\n                for(int j = 0; j < n; j++){\r\n                    grid[i][j] = Integer.parseInt(S[j]);\r\n                }\r\n            }\r\n            Solution obj = new Solution();\r\n            int ans = obj.minimumCostPath(grid);\r\n            System.out.println(ans);\r\n        }\r\n    }\r\n}\r\n// } Driver Code Ends\r\n\r\n\r\nclass Solution\r\n{\r\n    // Helper class to represent a cell with its coordinates and cost\r\n    static class Cell implements Comparable<Cell> {\r\n        int row, col, cost;\r\n\r\n        Cell(int row, int col, int cost) {\r\n            this.row = row;\r\n            this.col = col;\r\n            this.cost = cost;\r\n        }\r\n\r\n        @Override\r\n        public int compareTo(Cell other) {\r\n            return Integer.compare(this.cost, other.cost);\r\n        }\r\n    }\r\n\r\n    public int minimumCostPath(int[][] grid)\r\n    {\r\n        int rows = grid.length;\r\n        int cols = grid[0].length;\r\n\r\n        // Array to store the minimum cost to reach each cell\r\n        int[][] minCost = new int[rows][cols];\r\n        for (int[] row : minCost) {\r\n            Arrays.fill(row, Integer.MAX_VALUE);\r\n        }\r\n\r\n        // Priority queue to store cells with their current cost\r\n        PriorityQueue<Cell> pq = new PriorityQueue<>();\r\n\r\n        // Starting from the top-left cell\r\n        pq.offer(new Cell(0, 0, grid[0][0]));\r\n        minCost[0][0] = grid[0][0];\r\n\r\n        // Possible directions to move\r\n        int[] dr = {0, 0, 1, -1};\r\n        int[] dc = {1, -1, 0, 0};\r\n\r\n        while (!pq.isEmpty()) {\r\n            Cell current = pq.poll();\r\n\r\n            // Check all possible directions\r\n            for (int i = 0; i < 4; i++) {\r\n                int newRow = current.row + dr[i];\r\n                int newCol = current.col + dc[i];\r\n\r\n                // Check if the new position is within bounds\r\n                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {\r\n                    int newCost = current.cost + grid[newRow][newCol];\r\n\r\n                    // If the new cost is less than the current minimum cost to reach the cell\r\n                    if (newCost < minCost[newRow][newCol]) {\r\n                        // Update the minimum cost and add the cell to the priority queue\r\n                        minCost[newRow][newCol] = newCost;\r\n                        pq.offer(new Cell(newRow, newCol, newCost));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // The minimum cost to reach the bottom-right cell\r\n        return minCost[rows - 1][cols - 1];\r\n    }\r\n}",
  "status": "1",
  "language": "java",
  "user_code": "\r\n\r\nclass Solution\r\n{\r\n    // Helper class to represent a cell with its coordinates and cost\r\n    static class Cell implements Comparable<Cell> {\r\n        int row, col, cost;\r\n\r\n        Cell(int row, int col, int cost) {\r\n            this.row = row;\r\n            this.col = col;\r\n            this.cost = cost;\r\n        }\r\n\r\n        @Override\r\n        public int compareTo(Cell other) {\r\n            return Integer.compare(this.cost, other.cost);\r\n        }\r\n    }\r\n\r\n    public int minimumCostPath(int[][] grid)\r\n    {\r\n        int rows = grid.length;\r\n        int cols = grid[0].length;\r\n\r\n        // Array to store the minimum cost to reach each cell\r\n        int[][] minCost = new int[rows][cols];\r\n        for (int[] row : minCost) {\r\n            Arrays.fill(row, Integer.MAX_VALUE);\r\n        }\r\n\r\n        // Priority queue to store cells with their current cost\r\n        PriorityQueue<Cell> pq = new PriorityQueue<>();\r\n\r\n        // Starting from the top-left cell\r\n        pq.offer(new Cell(0, 0, grid[0][0]));\r\n        minCost[0][0] = grid[0][0];\r\n\r\n        // Possible directions to move\r\n        int[] dr = {0, 0, 1, -1};\r\n        int[] dc = {1, -1, 0, 0};\r\n\r\n        while (!pq.isEmpty()) {\r\n            Cell current = pq.poll();\r\n\r\n            // Check all possible directions\r\n            for (int i = 0; i < 4; i++) {\r\n                int newRow = current.row + dr[i];\r\n                int newCol = current.col + dc[i];\r\n\r\n                // Check if the new position is within bounds\r\n                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {\r\n                    int newCost = current.cost + grid[newRow][newCol];\r\n\r\n                    // If the new cost is less than the current minimum cost to reach the cell\r\n                    if (newCost < minCost[newRow][newCol]) {\r\n                        // Update the minimum cost and add the cell to the priority queue\r\n                        minCost[newRow][newCol] = newCost;\r\n                        pq.offer(new Cell(newRow, newCol, newCost));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // The minimum cost to reach the bottom-right cell\r\n        return minCost[rows - 1][cols - 1];\r\n    }\r\n}"
}