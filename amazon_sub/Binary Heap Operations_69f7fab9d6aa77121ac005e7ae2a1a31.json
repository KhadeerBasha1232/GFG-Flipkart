{
  "code": "// Initial Template for C++\r\n\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long int ll;\r\n\r\n// Structure for Min Heap\r\nstruct MinHeap {\r\n    int *harr;\r\n    int capacity;\r\n    int heap_size;\r\n\r\n    // Constructor for Min Heap\r\n    MinHeap(int c) {\r\n        heap_size = 0;\r\n        capacity = c;\r\n        harr = new int[c];\r\n    }\r\n\r\n    ~MinHeap() { delete[] harr; }\r\n\r\n    int parent(int i) { return (i - 1) / 2; }\r\n\r\n    int left(int i) { return (2 * i + 1); }\r\n\r\n    int right(int i) { return (2 * i + 2); }\r\n\r\n    void MinHeapify(int); // Implemented in user editor\r\n    int extractMin();\r\n    void decreaseKey(int i, int new_val);\r\n    void deleteKey(int i);\r\n    void insertKey(int k);\r\n};\r\n\r\n// Position this line where user code will be pasted.\r\n\r\n// Driver code\r\nint main() {\r\n    int t;\r\n    cin >> t;\r\n\r\n    while (t--) {\r\n        ll a;\r\n        cin >> a;\r\n        MinHeap h(a);\r\n        for (ll i = 0; i < a; i++) {\r\n            int c;\r\n            int n;\r\n            cin >> c;\r\n            if (c == 1) {\r\n                cin >> n;\r\n\r\n                h.insertKey(n);\r\n            }\r\n            if (c == 2) {\r\n                cin >> n;\r\n                h.deleteKey(n);\r\n            }\r\n            if (c == 3) {\r\n                cout << h.extractMin() << \" \";\r\n            }\r\n        }\r\n        cout << endl;\r\n        // delete h.harr;\r\n        h.harr = NULL;\r\n    }\r\n    return 0;\r\n}\r\n\r\n// } Driver Code Ends\r\n\r\n\r\n/*The structure of the class is\r\nstruct MinHeap\r\n{\r\n    int *harr;\r\n    int capacity, heap_size;\r\n    MinHeap(int cap) {heap_size = 0; capacity = cap; harr = new int[cap];}\r\n    int extractMin();\r\n    void deleteKey(int i);\r\n    void insertKey(int k);\r\n    int parent(int i);\r\n    int left(int i);\r\n    int right(int i);\r\n};*/\r\n\r\n\r\n\r\n//Function to extract minimum value in heap and then to store \r\n//next minimum value at first index.\r\nint MinHeap::extractMin() \r\n{\r\n    if (heap_size <= 0) return -1;\r\n    if (heap_size == 1) {\r\n        heap_size--;\r\n        return harr[0];\r\n    }\r\n\r\n    int root = harr[0];\r\n    //storing value of leaf node at first index.\r\n    harr[0] = harr[heap_size - 1];\r\n    harr[heap_size - 1] = 0;\r\n    heap_size--;\r\n\r\n    //calling heapify function for the first index.\r\n    MinHeapify(0); \r\n\r\n    return root;\r\n}\r\n\r\n//Function to delete a key at ith index.\r\nvoid MinHeap::deleteKey(int i)\r\n{\r\n     if (i < heap_size) \r\n    {\r\n        //decreasing value at ith index to minimum integer value.\r\n        decreaseKey(i, INT_MIN);\r\n        //extracting the minimum value from heap.\r\n        extractMin();\r\n    }\r\n}\r\n\r\n//Function to insert a value in Heap.\r\nvoid MinHeap::insertKey(int k) \r\n{\r\n    heap_size++;\r\n    int i = heap_size - 1;\r\n                             //inserting the value at leaf node.\r\n    harr[i] = k;             //at end of arr\r\n                             // travel right place\r\n    while (i != 0 && harr[parent(i)] > harr[i])\r\n    {                        //parrent(i)is index of parent of i index element \r\n                            //swapping values of ith index with its parent node\r\n                           //if value at parent node is greater.\r\n        swap(harr[i], harr[parent(i)]);\r\n        i = parent(i);\r\n    }\r\n}\r\n\r\n//Function to change value at ith index and store that value at first index.\r\nvoid MinHeap::decreaseKey(int i, int new_val) \r\n{\r\n    harr[i] = new_val;\r\n    while (i != 0 && harr[parent(i)] > harr[i]) {\r\n        swap(harr[i], harr[parent(i)]);\r\n        i = parent(i);\r\n    }\r\n}\r\n\r\n/* You may call below MinHeapify function in\r\n   above codes. Please do not delete this code\r\n   if you are not writing your own MinHeapify */\r\nvoid MinHeap::MinHeapify(int i) \r\n{\r\n    int l = left(i);\r\n    int r = right(i);\r\n    int smallest = i;\r\n    if (l < heap_size && harr[l] < harr[i]) smallest = l;\r\n    if (r < heap_size && harr[r] < harr[smallest]) smallest = r;\r\n    if (smallest != i) {\r\n        swap(harr[i], harr[smallest]);\r\n        MinHeapify(smallest);\r\n    }\r\n}",
  "status": "1",
  "language": "cpp",
  "user_code": "\r\n\r\n/*The structure of the class is\r\nstruct MinHeap\r\n{\r\n    int *harr;\r\n    int capacity, heap_size;\r\n    MinHeap(int cap) {heap_size = 0; capacity = cap; harr = new int[cap];}\r\n    int extractMin();\r\n    void deleteKey(int i);\r\n    void insertKey(int k);\r\n    int parent(int i);\r\n    int left(int i);\r\n    int right(int i);\r\n};*/\r\n\r\n\r\n\r\n//Function to extract minimum value in heap and then to store \r\n//next minimum value at first index.\r\nint MinHeap::extractMin() \r\n{\r\n    if (heap_size <= 0) return -1;\r\n    if (heap_size == 1) {\r\n        heap_size--;\r\n        return harr[0];\r\n    }\r\n\r\n    int root = harr[0];\r\n    //storing value of leaf node at first index.\r\n    harr[0] = harr[heap_size - 1];\r\n    harr[heap_size - 1] = 0;\r\n    heap_size--;\r\n\r\n    //calling heapify function for the first index.\r\n    MinHeapify(0); \r\n\r\n    return root;\r\n}\r\n\r\n//Function to delete a key at ith index.\r\nvoid MinHeap::deleteKey(int i)\r\n{\r\n     if (i < heap_size) \r\n    {\r\n        //decreasing value at ith index to minimum integer value.\r\n        decreaseKey(i, INT_MIN);\r\n        //extracting the minimum value from heap.\r\n        extractMin();\r\n    }\r\n}\r\n\r\n//Function to insert a value in Heap.\r\nvoid MinHeap::insertKey(int k) \r\n{\r\n    heap_size++;\r\n    int i = heap_size - 1;\r\n                             //inserting the value at leaf node.\r\n    harr[i] = k;             //at end of arr\r\n                             // travel right place\r\n    while (i != 0 && harr[parent(i)] > harr[i])\r\n    {                        //parrent(i)is index of parent of i index element \r\n                            //swapping values of ith index with its parent node\r\n                           //if value at parent node is greater.\r\n        swap(harr[i], harr[parent(i)]);\r\n        i = parent(i);\r\n    }\r\n}\r\n\r\n//Function to change value at ith index and store that value at first index.\r\nvoid MinHeap::decreaseKey(int i, int new_val) \r\n{\r\n    harr[i] = new_val;\r\n    while (i != 0 && harr[parent(i)] > harr[i]) {\r\n        swap(harr[i], harr[parent(i)]);\r\n        i = parent(i);\r\n    }\r\n}\r\n\r\n/* You may call below MinHeapify function in\r\n   above codes. Please do not delete this code\r\n   if you are not writing your own MinHeapify */\r\nvoid MinHeap::MinHeapify(int i) \r\n{\r\n    int l = left(i);\r\n    int r = right(i);\r\n    int smallest = i;\r\n    if (l < heap_size && harr[l] < harr[i]) smallest = l;\r\n    if (r < heap_size && harr[r] < harr[smallest]) smallest = r;\r\n    if (smallest != i) {\r\n        swap(harr[i], harr[smallest]);\r\n        MinHeapify(smallest);\r\n    }\r\n}"
}