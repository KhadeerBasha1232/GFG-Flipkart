{
  "code": "//Initial Template for C\r\n\r\n#include<stdio.h>\r\n\r\n// } Driver Code Ends\r\n//Back-end complete function Template for C\r\n\r\n/* C program for Merge Sort */\r\nvoid merge(int arr[], int l, int m, int r)\r\n{\r\n\tint i, j, k;\r\n\tint n1 = m - l + 1;\r\n\tint n2 = r - m;\r\n\r\n\t/* create temp arrays */\r\n\tint L[n1], R[n2];\r\n\r\n\t/* Copy data to temp arrays L[] and R[] */\r\n\tfor (i = 0; i < n1; i++)\r\n\t\tL[i] = arr[l + i];\r\n\tfor (j = 0; j < n2; j++)\r\n\t\tR[j] = arr[m + 1 + j];\r\n\r\n\t/* Merge the temp arrays back into arr[l..r]*/\r\n\ti = 0; // Initial index of first subarray\r\n\tj = 0; // Initial index of second subarray\r\n\tk = l; // Initial index of merged subarray\r\n\twhile (i < n1 && j < n2) {\r\n\t\tif (L[i] <= R[j]) {\r\n\t\t\tarr[k] = L[i];\r\n\t\t\ti++;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tarr[k] = R[j];\r\n\t\t\tj++;\r\n\t\t}\r\n\t\tk++;\r\n\t}\r\n\r\n\t/* Copy the remaining elements of L[], if there\r\n\tare any */\r\n\twhile (i < n1) {\r\n\t\tarr[k] = L[i];\r\n\t\ti++;\r\n\t\tk++;\r\n\t}\r\n\r\n\t/* Copy the remaining elements of R[], if there\r\n\tare any */\r\n\twhile (j < n2) {\r\n\t\tarr[k] = R[j];\r\n\t\tj++;\r\n\t\tk++;\r\n\t}\r\n}\r\n\r\n/* l is for left index and r is right index of the\r\nsub-array of arr to be sorted */\r\nvoid mergeSort(int arr[], int l, int r)\r\n{\r\n\tif (l < r) {\r\n\t\t// Same as (l+r)/2, but avoids overflow for\r\n\t\t// large l and h\r\n\t\tint m = l + (r - l) / 2;\r\n\r\n\t\t// Sort first and second halves\r\n\t\tmergeSort(arr, l, m);\r\n\t\tmergeSort(arr, m + 1, r);\r\n\r\n\t\tmerge(arr, l, m, r);\r\n\t}\r\n}\r\n\r\n\r\nint findTriplets(int arr[], int n){\r\n        \r\n        //Sorting the elements.\r\n        mergeSort(arr, 0, n-1);\r\n        \r\n        //Traversing the array elements.\r\n        for (int i=0; i<n-2; i++)\r\n        {\r\n            //Taking two pointers. One at element after ith index and another\r\n            //at the last index.\r\n            int l = i + 1;\r\n            int r = n - 1;\r\n            int x = arr[i];\r\n            \r\n            //Using two pointers over the array which helps in checking if\r\n            //the triplet sum is zero.\r\n            while (l < r)\r\n            {\r\n                //If sum of elements at indexes i, l and r is 0, we return true.\r\n                if (x + arr[l] + arr[r] == 0)\r\n                {\r\n    \t\t\t\treturn 1;\r\n                }\r\n                //Else if the sum is less than 0, it means we need to increase the\r\n                //sum so we increase the left pointer l.\r\n                else if (x + arr[l] + arr[r] < 0)\r\n                {\r\n                    l++;\r\n                }\r\n                //Else the sum is more than 0 and we need to decrease the\r\n                //sum so we decrease the right pointer r.\r\n                else\r\n                {\r\n                    r--;\r\n                }\r\n            }\r\n        }\r\n            //returning false if no triplet with zero sum is present.\r\n            return 0;\r\n    }\r\n\r\n//{ Driver Code Starts.\r\nint main()\r\n{\r\n    int t;\r\n\tscanf(\"%d\", &t);\r\n\twhile(t--){\r\n    \tint n;\r\n    \tscanf(\"%d\", &n);\r\n    \tint arr[n];\r\n    \tfor(int i=0;i<n;i++)\r\n    \t\tscanf(\"%d\", &arr[i]);\r\n        if(findTriplets(arr, n))\r\n            printf(\"1\\n\");\r\n        else \r\n            printf(\"0\\n\");\r\n\t}\r\n    return 0;\r\n}\r\n// } Driver Code Ends",
  "status": "1",
  "language": "c",
  "user_code": "//Back-end complete function Template for C\r\n\r\n/* C program for Merge Sort */\r\nvoid merge(int arr[], int l, int m, int r)\r\n{\r\n\tint i, j, k;\r\n\tint n1 = m - l + 1;\r\n\tint n2 = r - m;\r\n\r\n\t/* create temp arrays */\r\n\tint L[n1], R[n2];\r\n\r\n\t/* Copy data to temp arrays L[] and R[] */\r\n\tfor (i = 0; i < n1; i++)\r\n\t\tL[i] = arr[l + i];\r\n\tfor (j = 0; j < n2; j++)\r\n\t\tR[j] = arr[m + 1 + j];\r\n\r\n\t/* Merge the temp arrays back into arr[l..r]*/\r\n\ti = 0; // Initial index of first subarray\r\n\tj = 0; // Initial index of second subarray\r\n\tk = l; // Initial index of merged subarray\r\n\twhile (i < n1 && j < n2) {\r\n\t\tif (L[i] <= R[j]) {\r\n\t\t\tarr[k] = L[i];\r\n\t\t\ti++;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tarr[k] = R[j];\r\n\t\t\tj++;\r\n\t\t}\r\n\t\tk++;\r\n\t}\r\n\r\n\t/* Copy the remaining elements of L[], if there\r\n\tare any */\r\n\twhile (i < n1) {\r\n\t\tarr[k] = L[i];\r\n\t\ti++;\r\n\t\tk++;\r\n\t}\r\n\r\n\t/* Copy the remaining elements of R[], if there\r\n\tare any */\r\n\twhile (j < n2) {\r\n\t\tarr[k] = R[j];\r\n\t\tj++;\r\n\t\tk++;\r\n\t}\r\n}\r\n\r\n/* l is for left index and r is right index of the\r\nsub-array of arr to be sorted */\r\nvoid mergeSort(int arr[], int l, int r)\r\n{\r\n\tif (l < r) {\r\n\t\t// Same as (l+r)/2, but avoids overflow for\r\n\t\t// large l and h\r\n\t\tint m = l + (r - l) / 2;\r\n\r\n\t\t// Sort first and second halves\r\n\t\tmergeSort(arr, l, m);\r\n\t\tmergeSort(arr, m + 1, r);\r\n\r\n\t\tmerge(arr, l, m, r);\r\n\t}\r\n}\r\n\r\n\r\nint findTriplets(int arr[], int n){\r\n        \r\n        //Sorting the elements.\r\n        mergeSort(arr, 0, n-1);\r\n        \r\n        //Traversing the array elements.\r\n        for (int i=0; i<n-2; i++)\r\n        {\r\n            //Taking two pointers. One at element after ith index and another\r\n            //at the last index.\r\n            int l = i + 1;\r\n            int r = n - 1;\r\n            int x = arr[i];\r\n            \r\n            //Using two pointers over the array which helps in checking if\r\n            //the triplet sum is zero.\r\n            while (l < r)\r\n            {\r\n                //If sum of elements at indexes i, l and r is 0, we return true.\r\n                if (x + arr[l] + arr[r] == 0)\r\n                {\r\n    \t\t\t\treturn 1;\r\n                }\r\n                //Else if the sum is less than 0, it means we need to increase the\r\n                //sum so we increase the left pointer l.\r\n                else if (x + arr[l] + arr[r] < 0)\r\n                {\r\n                    l++;\r\n                }\r\n                //Else the sum is more than 0 and we need to decrease the\r\n                //sum so we decrease the right pointer r.\r\n                else\r\n                {\r\n                    r--;\r\n                }\r\n            }\r\n        }\r\n            //returning false if no triplet with zero sum is present.\r\n            return 0;\r\n    }\r\n"
}