{
  "code": "// Initial Template for C++\r\n\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n// } Driver Code Ends\r\n// User function Template for C++\r\n\r\nclass Solution{\r\n    public:\r\n    string findOrder(string dict[], int N, int K) {\r\n        //code here\r\n        vector<int> adj[K];\r\n        for(int i = 0; i < N-1; i++)\r\n        {\r\n            string curr = dict[i];\r\n            string next = dict[i+1];\r\n            int len = min(curr.length(),next.length());\r\n            int j = 0;\r\n            for(j = 0; j < len; j++)\r\n            {\r\n                if(curr[j] != next[j])\r\n                break;\r\n            }\r\n            if(j != len)\r\n            adj[curr[j] - 'a'].push_back(next[j] - 'a');\r\n        }\r\n        \r\n        queue<int> q;\r\n        string ans = \"\";\r\n        vector<int> indegree(K,0);\r\n        for(auto word : adj)\r\n        {\r\n            for(auto letter : word)\r\n            {\r\n                indegree[letter]++;\r\n            }\r\n        }\r\n        for(int i = 0; i < K; ++i)\r\n        {\r\n            if(indegree[i] == 0) q.push(i);\r\n        }\r\n\r\n        int count = 0;\r\n        while(!q.empty())\r\n        {\r\n            count++;\r\n            int node = q.front();\r\n            q.pop();\r\n            ans += char(node + 'a');\r\n            for(auto neighbor : adj[node])\r\n            {\r\n                indegree[neighbor]--;\r\n                if(indegree[neighbor] == 0) q.push(neighbor);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n\r\n//{ Driver Code Starts.\r\nstring order;\r\nbool f(string a, string b) {\r\n    int p1 = 0;\r\n    int p2 = 0;\r\n    for (int i = 0; i < min(a.size(), b.size()) and p1 == p2; i++) {\r\n        p1 = order.find(a[i]);\r\n        p2 = order.find(b[i]);\r\n        //\tcout<<p1<<\" \"<<p2<<endl;\r\n    }\r\n\r\n    if (p1 == p2 and a.size() != b.size()) return a.size() < b.size();\r\n\r\n    return p1 < p2;\r\n}\r\n\r\n// Driver program to test above functions\r\nint main() {\r\n    int t;\r\n    cin >> t;\r\n    while (t--) {\r\n        int N, K;\r\n        cin >> N >> K;\r\n        string dict[N];\r\n        for (int i = 0; i < N; i++) cin >> dict[i];\r\n        \r\n        Solution obj;\r\n        string ans = obj.findOrder(dict, N, K);\r\n        order = \"\";\r\n        for (int i = 0; i < ans.size(); i++) order += ans[i];\r\n\r\n        string temp[N];\r\n        std::copy(dict, dict + N, temp);\r\n        sort(temp, temp + N, f);\r\n\r\n        bool f = true;\r\n        for (int i = 0; i < N; i++)\r\n            if (dict[i] != temp[i]) f = false;\r\n\r\n        if(f)cout << 1;\r\n        else cout << 0;\r\n        cout << endl;\r\n    }\r\n    return 0;\r\n}\r\n\r\n// } Driver Code Ends",
  "status": "1",
  "language": "cpp",
  "user_code": "// User function Template for C++\r\n\r\nclass Solution{\r\n    public:\r\n    string findOrder(string dict[], int N, int K) {\r\n        //code here\r\n        vector<int> adj[K];\r\n        for(int i = 0; i < N-1; i++)\r\n        {\r\n            string curr = dict[i];\r\n            string next = dict[i+1];\r\n            int len = min(curr.length(),next.length());\r\n            int j = 0;\r\n            for(j = 0; j < len; j++)\r\n            {\r\n                if(curr[j] != next[j])\r\n                break;\r\n            }\r\n            if(j != len)\r\n            adj[curr[j] - 'a'].push_back(next[j] - 'a');\r\n        }\r\n        \r\n        queue<int> q;\r\n        string ans = \"\";\r\n        vector<int> indegree(K,0);\r\n        for(auto word : adj)\r\n        {\r\n            for(auto letter : word)\r\n            {\r\n                indegree[letter]++;\r\n            }\r\n        }\r\n        for(int i = 0; i < K; ++i)\r\n        {\r\n            if(indegree[i] == 0) q.push(i);\r\n        }\r\n\r\n        int count = 0;\r\n        while(!q.empty())\r\n        {\r\n            count++;\r\n            int node = q.front();\r\n            q.pop();\r\n            ans += char(node + 'a');\r\n            for(auto neighbor : adj[node])\r\n            {\r\n                indegree[neighbor]--;\r\n                if(indegree[neighbor] == 0) q.push(neighbor);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n"
}