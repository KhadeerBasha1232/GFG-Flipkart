{
  "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n\r\n// } Driver Code Ends\r\n// design the class in the most optimal way\r\n\r\nclass LRUCache\r\n{\r\npublic:\r\n    LRUCache(int cap) : m_cap(cap) { }\r\n\r\n    int GET(int key)\r\n    {\r\n        return apply(key,\r\n                     [](int value) { return value; },\r\n                     []() { return -1; });\r\n    }\r\n\r\n    void SET(int key, int value)\r\n    {\r\n        apply(key,\r\n              [&value](int& valueRef){ valueRef = value; },\r\n              [&](){\r\n                  m_list.emplace_back(key, value);\r\n                  m_map.emplace(key, std::prev(m_list.end()));\r\n\r\n                  if (m_map.size() > m_cap)\r\n                  {\r\n                      m_map.erase(m_list.front().first);\r\n                      m_list.pop_front();\r\n                  }\r\n              });\r\n    }\r\n\r\nprivate:\r\n    template <typename OnFound, typename OnNotFound>\r\n    auto apply(int key, OnFound&& onFound, OnNotFound&& onNotFound) -> decltype(onNotFound())\r\n    {\r\n        auto it = m_map.find(key);\r\n        if (it == m_map.end())\r\n            return onNotFound();\r\n\r\n        m_list.splice(m_list.end(), m_list, it->second);\r\n        return onFound(it->second->second);\r\n    }\r\n\r\nprivate:\r\n\r\n    int m_cap;\r\n    \r\n    using List = std::list<std::pair<const int, int>>;\r\n    List m_list;\r\n    std::unordered_map<int, List::iterator> m_map;\r\n};\r\n\r\n//{ Driver Code Starts.\r\n\r\nint main()\r\n{\r\n    int t;\r\n    cin >> t;\r\n    while (t--)\r\n    {\r\n\r\n        int capacity;\r\n        cin >> capacity;\r\n        LRUCache *cache = new LRUCache(capacity);\r\n        \r\n        int queries;\r\n        cin >> queries;\r\n        while (queries--)\r\n        {\r\n            string q;\r\n            cin >> q;\r\n            if (q == \"SET\")\r\n            {\r\n                int key;\r\n                cin >> key;\r\n                int value;\r\n                cin >> value;\r\n                cache->SET(key, value);\r\n            }\r\n            else\r\n            {\r\n                int key;\r\n                cin >> key;\r\n                cout << cache->GET(key) << \" \";\r\n            }\r\n        }\r\n        cout << endl;\r\n    }\r\n    return 0;\r\n}\r\n\r\n// } Driver Code Ends",
  "status": "1",
  "language": "cpp",
  "user_code": "// design the class in the most optimal way\r\n\r\nclass LRUCache\r\n{\r\npublic:\r\n    LRUCache(int cap) : m_cap(cap) { }\r\n\r\n    int GET(int key)\r\n    {\r\n        return apply(key,\r\n                     [](int value) { return value; },\r\n                     []() { return -1; });\r\n    }\r\n\r\n    void SET(int key, int value)\r\n    {\r\n        apply(key,\r\n              [&value](int& valueRef){ valueRef = value; },\r\n              [&](){\r\n                  m_list.emplace_back(key, value);\r\n                  m_map.emplace(key, std::prev(m_list.end()));\r\n\r\n                  if (m_map.size() > m_cap)\r\n                  {\r\n                      m_map.erase(m_list.front().first);\r\n                      m_list.pop_front();\r\n                  }\r\n              });\r\n    }\r\n\r\nprivate:\r\n    template <typename OnFound, typename OnNotFound>\r\n    auto apply(int key, OnFound&& onFound, OnNotFound&& onNotFound) -> decltype(onNotFound())\r\n    {\r\n        auto it = m_map.find(key);\r\n        if (it == m_map.end())\r\n            return onNotFound();\r\n\r\n        m_list.splice(m_list.end(), m_list, it->second);\r\n        return onFound(it->second->second);\r\n    }\r\n\r\nprivate:\r\n\r\n    int m_cap;\r\n    \r\n    using List = std::list<std::pair<const int, int>>;\r\n    List m_list;\r\n    std::unordered_map<int, List::iterator> m_map;\r\n};\r\n"
}