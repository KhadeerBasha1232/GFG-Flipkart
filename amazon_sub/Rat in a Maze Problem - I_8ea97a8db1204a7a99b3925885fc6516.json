{
  "code": "// Initial template for C++\r\n\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n\r\n// } Driver Code Ends\r\n// User function template for C++\r\n\r\nclass Solution{\r\nprivate:\r\n    bool possible(vector<vector<int>>& visited, int n, vector<vector<int>>& m, int x, int y){\r\n        if((x >= 0 && x < n) && (y >= 0 && y < n) && m[x][y] == 1 && visited[x][y] == 0 ){\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    \r\n    void Source(vector<string>& ans, vector<vector<int>>& m, int n, vector<vector<int>> visited, string path,\r\n                int x, int y){\r\n        // base case\r\n        if(x == n-1 && y == n-1){\r\n            ans.push_back(path);\r\n            return;\r\n        }\r\n        visited[x][y] = 1;\r\n        \r\n        // down\r\n        int xpre = x + 1;\r\n        int ypre = y;\r\n        if(possible(visited, n, m, xpre, ypre)){\r\n            path.push_back('D');\r\n            Source(ans, m, n, visited, path, xpre, ypre);\r\n            path.pop_back();\r\n        }\r\n        \r\n        // left\r\n        xpre = x;\r\n        ypre = y - 1;\r\n        if(possible(visited, n, m, xpre, ypre)){\r\n            path.push_back('L');\r\n            Source(ans, m, n, visited, path, xpre, ypre);\r\n            path.pop_back();\r\n        }\r\n        \r\n        // right\r\n        xpre = x;\r\n        ypre = y + 1; // Corrected y + 1\r\n        if(possible(visited, n, m, xpre, ypre)){\r\n            path.push_back('R');\r\n            Source(ans, m, n, visited, path, xpre, ypre);\r\n            path.pop_back();\r\n        }\r\n        \r\n        // up\r\n        xpre = x - 1;\r\n        ypre = y;\r\n        if(possible(visited, n, m, xpre, ypre)){\r\n            path.push_back('U');\r\n            Source(ans, m, n, visited, path, xpre, ypre);\r\n            path.pop_back();\r\n        }\r\n        \r\n        visited[x][y] = 0;  \r\n    }\r\n    \r\npublic:\r\n    vector<string> findPath(vector<vector<int>>& m, int n) {\r\n        vector<string> ans;\r\n        if(m[0][0] == 0){\r\n            return ans;\r\n        }\r\n        int srcx = 0;\r\n        int srcy = 0;\r\n        \r\n        vector<vector<int>> visited(n, vector<int>(n, 0)); // Fixed initialization of visited\r\n        \r\n        string path = \"\";\r\n        \r\n        Source(ans, m, n, visited, path, srcx, srcy);\r\n        \r\n        sort(ans.begin(), ans.end());\r\n        return ans;\r\n    }\r\n};\r\n\r\n\r\n    \r\n\r\n\r\n//{ Driver Code Starts.\r\n\r\nint main() {\r\n    int t;\r\n    cin >> t;\r\n    while (t--) {\r\n        int n;\r\n        cin >> n;\r\n        vector<vector<int>> m(n, vector<int> (n,0));\r\n        for (int i = 0; i < n; i++) {\r\n            for (int j = 0; j < n; j++) {\r\n                cin >> m[i][j];\r\n            }\r\n        }\r\n        Solution obj;\r\n        vector<string> result = obj.findPath(m, n);\r\n        sort(result.begin(), result.end());\r\n        if (result.size() == 0)\r\n            cout << -1;\r\n        else\r\n            for (int i = 0; i < result.size(); i++) cout << result[i] << \" \";\r\n        cout << endl;\r\n    }\r\n    return 0;\r\n}\r\n// } Driver Code Ends",
  "status": "1",
  "language": "cpp",
  "user_code": "// User function template for C++\r\n\r\nclass Solution{\r\nprivate:\r\n    bool possible(vector<vector<int>>& visited, int n, vector<vector<int>>& m, int x, int y){\r\n        if((x >= 0 && x < n) && (y >= 0 && y < n) && m[x][y] == 1 && visited[x][y] == 0 ){\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    \r\n    void Source(vector<string>& ans, vector<vector<int>>& m, int n, vector<vector<int>> visited, string path,\r\n                int x, int y){\r\n        // base case\r\n        if(x == n-1 && y == n-1){\r\n            ans.push_back(path);\r\n            return;\r\n        }\r\n        visited[x][y] = 1;\r\n        \r\n        // down\r\n        int xpre = x + 1;\r\n        int ypre = y;\r\n        if(possible(visited, n, m, xpre, ypre)){\r\n            path.push_back('D');\r\n            Source(ans, m, n, visited, path, xpre, ypre);\r\n            path.pop_back();\r\n        }\r\n        \r\n        // left\r\n        xpre = x;\r\n        ypre = y - 1;\r\n        if(possible(visited, n, m, xpre, ypre)){\r\n            path.push_back('L');\r\n            Source(ans, m, n, visited, path, xpre, ypre);\r\n            path.pop_back();\r\n        }\r\n        \r\n        // right\r\n        xpre = x;\r\n        ypre = y + 1; // Corrected y + 1\r\n        if(possible(visited, n, m, xpre, ypre)){\r\n            path.push_back('R');\r\n            Source(ans, m, n, visited, path, xpre, ypre);\r\n            path.pop_back();\r\n        }\r\n        \r\n        // up\r\n        xpre = x - 1;\r\n        ypre = y;\r\n        if(possible(visited, n, m, xpre, ypre)){\r\n            path.push_back('U');\r\n            Source(ans, m, n, visited, path, xpre, ypre);\r\n            path.pop_back();\r\n        }\r\n        \r\n        visited[x][y] = 0;  \r\n    }\r\n    \r\npublic:\r\n    vector<string> findPath(vector<vector<int>>& m, int n) {\r\n        vector<string> ans;\r\n        if(m[0][0] == 0){\r\n            return ans;\r\n        }\r\n        int srcx = 0;\r\n        int srcy = 0;\r\n        \r\n        vector<vector<int>> visited(n, vector<int>(n, 0)); // Fixed initialization of visited\r\n        \r\n        string path = \"\";\r\n        \r\n        Source(ans, m, n, visited, path, srcx, srcy);\r\n        \r\n        sort(ans.begin(), ans.end());\r\n        return ans;\r\n    }\r\n};\r\n\r\n\r\n    \r\n\r\n"
}