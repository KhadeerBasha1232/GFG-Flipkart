{
  "code": "import java.util.*;\r\nimport java.lang.*;\r\nimport java.io.*;\r\nclass GFG\r\n{\r\n    public static void main(String[] args) throws IOException\r\n    {\r\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n        int T = Integer.parseInt(br.readLine().trim());\r\n        while(T-->0)\r\n        {\r\n            int N = Integer.parseInt(br.readLine().trim());\r\n            String[] S1 = br.readLine().trim().split(\" \");\r\n            String[] S2 = br.readLine().trim().split(\" \");\r\n            int[] KnightPos = new int[2];\r\n            int[] TargetPos = new int[2];\r\n            for(int i = 0; i < 2; i++){\r\n                KnightPos[i] = Integer.parseInt(S1[i]);\r\n                TargetPos[i] = Integer.parseInt(S2[i]);\r\n            }\r\n            Solution obj = new Solution();\r\n            int ans = obj.minStepToReachTarget(KnightPos, TargetPos, N);\r\n            System.out.println(ans);\r\n       }\r\n    }\r\n}\r\n\r\n// } Driver Code Ends\r\n\r\n\r\n// import java.util.Arrays;\r\n// import java.util.LinkedList;\r\n// import java.util.Queue;\r\n\r\nclass Solution {\r\n    // Function to find out the minimum steps Knight needs to reach the target position.\r\n    public int minStepToReachTarget(int[] KnightPos, int[] TargetPos, int N) {\r\n        // Possible moves for the Knight\r\n        int[] dx = {-2, -1, 1, 2, 2, 1, -1, -2};\r\n        int[] dy = {1, 2, 2, 1, -1, -2, -2, -1};\r\n\r\n        // Create a chessboard to mark visited positions and store the steps\r\n        int[][] chessboard = new int[N + 1][N + 1];\r\n        for (int[] row : chessboard) {\r\n            Arrays.fill(row, -1);\r\n        }\r\n\r\n        // Queue to perform BFS\r\n        Queue<int[]> queue = new LinkedList<>();\r\n        queue.offer(KnightPos);\r\n        chessboard[KnightPos[0]][KnightPos[1]] = 0;\r\n\r\n        // Perform BFS\r\n        while (!queue.isEmpty()) {\r\n            int[] currentPos = queue.poll();\r\n\r\n            if (currentPos[0] == TargetPos[0] && currentPos[1] == TargetPos[1]) {\r\n                return chessboard[currentPos[0]][currentPos[1]];\r\n            }\r\n\r\n            for (int i = 0; i < 8; i++) {\r\n                int newX = currentPos[0] + dx[i];\r\n                int newY = currentPos[1] + dy[i];\r\n\r\n                if (newX >= 1 && newX <= N && newY >= 1 && newY <= N && chessboard[newX][newY] == -1) {\r\n                    chessboard[newX][newY] = chessboard[currentPos[0]][currentPos[1]] + 1;\r\n                    queue.offer(new int[]{newX, newY});\r\n                }\r\n            }\r\n        }\r\n\r\n        // If the target position is not reachable\r\n        return -1;\r\n    }\r\n}\r\n",
  "status": "1",
  "language": "java",
  "user_code": "\r\n\r\n// import java.util.Arrays;\r\n// import java.util.LinkedList;\r\n// import java.util.Queue;\r\n\r\nclass Solution {\r\n    // Function to find out the minimum steps Knight needs to reach the target position.\r\n    public int minStepToReachTarget(int[] KnightPos, int[] TargetPos, int N) {\r\n        // Possible moves for the Knight\r\n        int[] dx = {-2, -1, 1, 2, 2, 1, -1, -2};\r\n        int[] dy = {1, 2, 2, 1, -1, -2, -2, -1};\r\n\r\n        // Create a chessboard to mark visited positions and store the steps\r\n        int[][] chessboard = new int[N + 1][N + 1];\r\n        for (int[] row : chessboard) {\r\n            Arrays.fill(row, -1);\r\n        }\r\n\r\n        // Queue to perform BFS\r\n        Queue<int[]> queue = new LinkedList<>();\r\n        queue.offer(KnightPos);\r\n        chessboard[KnightPos[0]][KnightPos[1]] = 0;\r\n\r\n        // Perform BFS\r\n        while (!queue.isEmpty()) {\r\n            int[] currentPos = queue.poll();\r\n\r\n            if (currentPos[0] == TargetPos[0] && currentPos[1] == TargetPos[1]) {\r\n                return chessboard[currentPos[0]][currentPos[1]];\r\n            }\r\n\r\n            for (int i = 0; i < 8; i++) {\r\n                int newX = currentPos[0] + dx[i];\r\n                int newY = currentPos[1] + dy[i];\r\n\r\n                if (newX >= 1 && newX <= N && newY >= 1 && newY <= N && chessboard[newX][newY] == -1) {\r\n                    chessboard[newX][newY] = chessboard[currentPos[0]][currentPos[1]] + 1;\r\n                    queue.offer(new int[]{newX, newY});\r\n                }\r\n            }\r\n        }\r\n\r\n        // If the target position is not reachable\r\n        return -1;\r\n    }\r\n}\r\n"
}