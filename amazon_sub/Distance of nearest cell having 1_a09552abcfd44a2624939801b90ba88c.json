{
  "code": "import java.util.*;\r\nimport java.lang.*;\r\nimport java.io.*;\r\nclass GFG\r\n{\r\n    public static void main(String[] args) throws IOException\r\n    {\r\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n        int T = Integer.parseInt(br.readLine().trim());\r\n        while(T-->0)\r\n        {\r\n            String[] s = br.readLine().trim().split(\" \");\r\n            int n = Integer.parseInt(s[0]);\r\n            int m = Integer.parseInt(s[1]);\r\n            int[][] grid = new int[n][m];\r\n            for(int i = 0; i < n; i++){\r\n                String[] S = br.readLine().trim().split(\" \");\r\n                for(int j = 0; j < m; j++){\r\n                    grid[i][j] = Integer.parseInt(S[j]);\r\n                }\r\n            }\r\n            Solution obj = new Solution();\r\n            int[][] ans = obj.nearest(grid);\r\n            for(int i = 0; i < ans.length; i++){\r\n                for(int j = 0; j < ans[i].length; j++){\r\n                    System.out.print(ans[i][j] + \" \");\r\n                }\r\n                System.out.println();\r\n            }\r\n        }\r\n    }\r\n}\r\n// } Driver Code Ends\r\n\r\n\r\n// import java.util.LinkedList;\r\n// import java.util.Queue;\r\n\r\nclass Solution {\r\n    public int[][] nearest(int[][] grid) {\r\n        int rows = grid.length;\r\n        int cols = grid[0].length;\r\n\r\n        int[][] result = new int[rows][cols];\r\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\r\n\r\n        Queue<int[]> queue = new LinkedList<>();\r\n\r\n        // Initialize result matrix with maximum possible distances\r\n        for (int i = 0; i < rows; i++) {\r\n            for (int j = 0; j < cols; j++) {\r\n                result[i][j] = Integer.MAX_VALUE;\r\n                if (grid[i][j] == 1) {\r\n                    result[i][j] = 0;\r\n                    queue.offer(new int[]{i, j});\r\n                }\r\n            }\r\n        }\r\n\r\n        // Perform BFS traversal\r\n        while (!queue.isEmpty()) {\r\n            int[] current = queue.poll();\r\n            int currentRow = current[0];\r\n            int currentCol = current[1];\r\n\r\n            for (int[] direction : directions) {\r\n                int newRow = currentRow + direction[0];\r\n                int newCol = currentCol + direction[1];\r\n\r\n                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols\r\n                        && result[newRow][newCol] > result[currentRow][currentCol] + 1) {\r\n                    result[newRow][newCol] = result[currentRow][currentCol] + 1;\r\n                    queue.offer(new int[]{newRow, newCol});\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n",
  "status": "1",
  "language": "java",
  "user_code": "\r\n\r\n// import java.util.LinkedList;\r\n// import java.util.Queue;\r\n\r\nclass Solution {\r\n    public int[][] nearest(int[][] grid) {\r\n        int rows = grid.length;\r\n        int cols = grid[0].length;\r\n\r\n        int[][] result = new int[rows][cols];\r\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\r\n\r\n        Queue<int[]> queue = new LinkedList<>();\r\n\r\n        // Initialize result matrix with maximum possible distances\r\n        for (int i = 0; i < rows; i++) {\r\n            for (int j = 0; j < cols; j++) {\r\n                result[i][j] = Integer.MAX_VALUE;\r\n                if (grid[i][j] == 1) {\r\n                    result[i][j] = 0;\r\n                    queue.offer(new int[]{i, j});\r\n                }\r\n            }\r\n        }\r\n\r\n        // Perform BFS traversal\r\n        while (!queue.isEmpty()) {\r\n            int[] current = queue.poll();\r\n            int currentRow = current[0];\r\n            int currentCol = current[1];\r\n\r\n            for (int[] direction : directions) {\r\n                int newRow = currentRow + direction[0];\r\n                int newCol = currentCol + direction[1];\r\n\r\n                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols\r\n                        && result[newRow][newCol] > result[currentRow][currentCol] + 1) {\r\n                    result[newRow][newCol] = result[currentRow][currentCol] + 1;\r\n                    queue.offer(new int[]{newRow, newCol});\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n"
}