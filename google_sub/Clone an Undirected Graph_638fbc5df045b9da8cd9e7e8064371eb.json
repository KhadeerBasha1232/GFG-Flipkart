{
  "code": "//Initial Template for C++\r\n\r\n#include <bits/stdc++.h>\r\n#include <sstream>\r\nusing namespace std;\r\n\r\nstruct Node {\r\n    int val;\r\n    vector<Node*> neighbors;\r\n    Node() {\r\n        val = 0;\r\n        neighbors = vector<Node*>();\r\n    }\r\n    Node(int _val) {\r\n        val = _val;\r\n        neighbors = vector<Node*>();\r\n    }\r\n    Node(int _val, vector<Node*> _neighbors) {\r\n        val = _val;\r\n        neighbors = _neighbors;\r\n    }\r\n};\r\nvector<Node*> bfs(Node *src){\r\n    vector<Node*>ans;\r\n    map<Node*, bool> visit;\r\n    queue<Node*> q;\r\n    q.push(src);\r\n    visit[src] = true;\r\n    while (!q.empty()) {\r\n        Node *u = q.front();\r\n        ans.push_back(u);\r\n        q.pop();\r\n        vector<Node *> v = u->neighbors;\r\n        int n = v.size();\r\n        for (int i = 0; i < n; i++){\r\n            if (!visit[v[i]]){\r\n                visit[v[i]] = true;\r\n                q.push(v[i]);\r\n            }\r\n        }\r\n    }\r\n    return ans;\r\n}\r\n\r\nbool compare(Node* prev, Node* new_node, unordered_set<Node*>& prev_vis, unordered_set<Node*>& new_vis) {\r\n    if (prev == new_node) {\r\n        return false;\r\n    }\r\n    if (!prev || !new_node) {\r\n        if ((!prev && new_node) || (prev && !new_node)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    if (prev_vis.count(prev) || new_vis.count(new_node)) {\r\n        if ((prev_vis.count(prev) && !new_vis.count(new_node)) || (!prev_vis.count(prev) && new_vis.count(new_node))) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    prev_vis.insert(prev);\r\n    new_vis.insert(new_node);\r\n\r\n    if (prev->val != new_node->val) {\r\n        return false;\r\n    }\r\n\r\n    size_t prev_n = prev->neighbors.size();\r\n    size_t new_n = new_node->neighbors.size();\r\n    if (prev_n != new_n) {\r\n        return false;\r\n    }\r\n\r\n    sort(prev->neighbors.begin(), prev->neighbors.end(), [](Node* a, Node* b) { return a->val < b->val; });\r\n    sort(new_node->neighbors.begin(), new_node->neighbors.end(), [](Node* a, Node* b) { return a->val < b->val; });\r\n\r\n    for (size_t i = 0; i < prev_n; ++i) {\r\n        if (!compare(prev->neighbors[i], new_node->neighbors[i], prev_vis, new_vis)) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n\r\n// } Driver Code Ends\r\n//User function Template for C++\r\n\r\n// struct Node {\r\n//     int val;\r\n//     vector<Node*> neighbors;\r\n//     Node() {\r\n//         val = 0;\r\n//         neighbors = vector<Node*>();\r\n//     }\r\n//     Node(int _val) {\r\n//         val = _val;\r\n//         neighbors = vector<Node*>();\r\n//     }\r\n//     Node(int _val, vector<Node*> _neighbors) {\r\n//         val = _val;\r\n//         neighbors = _neighbors;\r\n//     }\r\n// };\r\n\r\nclass Solution {\r\npublic:\r\n    Node* cloneGraph(Node* node) {\r\n        Node* graph = new Node(node->val);\r\n        vector<Node*> vis(10001,NULL);\r\n        vis[node->val]=graph;\r\n        queue<pair<Node*, Node*>> q;\r\n        q.push({graph,node});\r\n        while(!q.empty()){\r\n            Node* _new=q.front().first;\r\n            Node* old=q.front().second;\r\n            q.pop();\r\n            for(auto x:old->neighbors){\r\n                Node* tmp=vis[x->val];\r\n                if(!tmp){\r\n                    tmp=new Node(x->val);\r\n                    vis[x->val]=tmp;\r\n                    q.push({tmp,x});\r\n                }\r\n                _new->neighbors.push_back(tmp);\r\n            }\r\n        }\r\n        return graph;\r\n    }\r\n};\r\n\r\n\r\n//{ Driver Code Starts.\r\nint main() {\r\n    int t;\r\n    cin >> t;\r\n    while (t--) {\r\n        int N;\r\n        cin >> N;\r\n        Node* root = NULL;\r\n        vector<Node*>v(N);\r\n        std::string buffer;\r\n        std::getline(std::cin, buffer);\r\n        for (int i = 0; i < N; i++)v[i] = new Node(i);\r\n        for (int i = 0; i < N; i++) {\r\n            std::vector<Node*> vec;\r\n            std::string buffer;\r\n            int data;\r\n            std::getline(std::cin, buffer);\r\n            std::istringstream iss(buffer);\r\n            while (iss >> data)\r\n                vec.push_back(v[data]);\r\n            v[i]->neighbors = vec;\r\n        }\r\n        Solution ob;\r\n        vector<Node*>prev = bfs(v[0]);\r\n        Node* ans = ob.cloneGraph(v[0]);\r\n        //vector<Node*>now = bfs(ans);\r\n        unordered_set<Node*>prev_vis, new_vis;\r\n        cout << compare(v[0], ans, prev_vis, new_vis) << endl;\r\n\r\n    }\r\n    return 0;\r\n}\r\n// } Driver Code Ends",
  "status": "1",
  "language": "cpp",
  "user_code": "//User function Template for C++\r\n\r\n// struct Node {\r\n//     int val;\r\n//     vector<Node*> neighbors;\r\n//     Node() {\r\n//         val = 0;\r\n//         neighbors = vector<Node*>();\r\n//     }\r\n//     Node(int _val) {\r\n//         val = _val;\r\n//         neighbors = vector<Node*>();\r\n//     }\r\n//     Node(int _val, vector<Node*> _neighbors) {\r\n//         val = _val;\r\n//         neighbors = _neighbors;\r\n//     }\r\n// };\r\n\r\nclass Solution {\r\npublic:\r\n    Node* cloneGraph(Node* node) {\r\n        Node* graph = new Node(node->val);\r\n        vector<Node*> vis(10001,NULL);\r\n        vis[node->val]=graph;\r\n        queue<pair<Node*, Node*>> q;\r\n        q.push({graph,node});\r\n        while(!q.empty()){\r\n            Node* _new=q.front().first;\r\n            Node* old=q.front().second;\r\n            q.pop();\r\n            for(auto x:old->neighbors){\r\n                Node* tmp=vis[x->val];\r\n                if(!tmp){\r\n                    tmp=new Node(x->val);\r\n                    vis[x->val]=tmp;\r\n                    q.push({tmp,x});\r\n                }\r\n                _new->neighbors.push_back(tmp);\r\n            }\r\n        }\r\n        return graph;\r\n    }\r\n};\r\n\r\n"
}