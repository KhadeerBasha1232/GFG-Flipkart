{
  "code": "import java.util.*;\r\n\r\nclass FindMinCost\r\n{\r\n\tpublic static void main(String args[])\r\n\t{\r\n\t\tScanner sc = new Scanner(System.in);\r\n\t\tint t = sc.nextInt();\r\n\t\twhile(t > 0)\r\n\t\t{\r\n\t\t\tint n = sc.nextInt();\r\n\t\t\tint m = 2;\r\n\t\t\tint arr[][] = new int[n][m];\r\n\t\t\tfor(int i=0; i<n; i++)\r\n\t\t\t{\r\n\t\t\t\tfor(int j=0; j<m; j++ )\r\n\t\t\t\t{\r\n\t\t\t\t\tarr[i][j] = sc.nextInt();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tSystem.out.println(new Solution().RemoveStones(arr, n));\r\n\t\tt--;\r\n\t\t}\r\n\t}\r\n}\r\n// } Driver Code Ends\r\n\r\nclass Solution {\r\n\r\n    int[] par;\r\n\r\n    int findParent(int c){\r\n        while(par[c]!=-1){\r\n            c=par[c];\r\n        }\r\n        return c;\r\n    }\r\n    public int RemoveStones(int[][] stones, int n) {\r\n        if(n<=1)return 0;\r\n        int[] arr=new int[n];\r\n        par=new int[n];\r\n        for(int i=0; i<n; i++){\r\n            par[i]=-1;\r\n        }\r\n        HashMap<Integer, Integer> row=new HashMap<>();\r\n        HashMap<Integer, Integer> col=new HashMap<>();\r\n        int c=0;\r\n        row.put(stones[0][0],c);\r\n        col.put(stones[0][1],c);\r\n        c++;\r\n        arr[0]++;\r\n        for(int i=1; i<n; i++){\r\n            if(row.containsKey(stones[i][0]) || col.containsKey(stones[i][1])){\r\n                int comp1=-1;\r\n                int comp2=-1;\r\n                if(row.containsKey(stones[i][0])){\r\n                    comp1=row.get(stones[i][0]);\r\n                }\r\n                if(col.containsKey(stones[i][1])){\r\n                    comp2=col.get(stones[i][1]);\r\n                }\r\n                if(comp1!=-1 && comp2!=-1 && comp1!=comp2){\r\n                    //kisi ka child h\r\n                    comp1=findParent(comp1);\r\n                    comp2=findParent(comp2);\r\n                    if(comp1==comp2)arr[comp1]++;\r\n                    //ultimate parent h\r\n                    else{\r\n                        if(comp1<comp2){\r\n                            par[comp2]=comp1;\r\n                            arr[comp1]=arr[comp1]+arr[comp2]+1;\r\n                            arr[comp2]=0;\r\n                        }\r\n                        else {\r\n                            par[comp1]=comp2;\r\n                            arr[comp2]=arr[comp2]+arr[comp1]+1;\r\n                            arr[comp1]=0;\r\n                        }\r\n                    }\r\n                }\r\n                else{\r\n                    if(comp2==-1)comp2=comp1;\r\n                    else if(comp1==-1)comp1=comp2;\r\n                    row.put(stones[i][0],comp1);\r\n                    col.put(stones[i][1],comp2);\r\n                    if(par[comp1]==-1)arr[comp1]++;\r\n                    else{\r\n                        arr[findParent(comp1)]++;\r\n                    }\r\n                }\r\n            }\r\n            else{\r\n                row.put(stones[i][0],c);\r\n                col.put(stones[i][1],c);\r\n                arr[c]++;\r\n                c++;\r\n            }\r\n        }\r\n        int max=0;\r\n        for(int i=0; i<n; i++){\r\n            if(arr[i]!=0){\r\n                max=max+arr[i]-1;\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n}\r\n",
  "status": "1",
  "language": "java",
  "user_code": "\r\nclass Solution {\r\n\r\n    int[] par;\r\n\r\n    int findParent(int c){\r\n        while(par[c]!=-1){\r\n            c=par[c];\r\n        }\r\n        return c;\r\n    }\r\n    public int RemoveStones(int[][] stones, int n) {\r\n        if(n<=1)return 0;\r\n        int[] arr=new int[n];\r\n        par=new int[n];\r\n        for(int i=0; i<n; i++){\r\n            par[i]=-1;\r\n        }\r\n        HashMap<Integer, Integer> row=new HashMap<>();\r\n        HashMap<Integer, Integer> col=new HashMap<>();\r\n        int c=0;\r\n        row.put(stones[0][0],c);\r\n        col.put(stones[0][1],c);\r\n        c++;\r\n        arr[0]++;\r\n        for(int i=1; i<n; i++){\r\n            if(row.containsKey(stones[i][0]) || col.containsKey(stones[i][1])){\r\n                int comp1=-1;\r\n                int comp2=-1;\r\n                if(row.containsKey(stones[i][0])){\r\n                    comp1=row.get(stones[i][0]);\r\n                }\r\n                if(col.containsKey(stones[i][1])){\r\n                    comp2=col.get(stones[i][1]);\r\n                }\r\n                if(comp1!=-1 && comp2!=-1 && comp1!=comp2){\r\n                    //kisi ka child h\r\n                    comp1=findParent(comp1);\r\n                    comp2=findParent(comp2);\r\n                    if(comp1==comp2)arr[comp1]++;\r\n                    //ultimate parent h\r\n                    else{\r\n                        if(comp1<comp2){\r\n                            par[comp2]=comp1;\r\n                            arr[comp1]=arr[comp1]+arr[comp2]+1;\r\n                            arr[comp2]=0;\r\n                        }\r\n                        else {\r\n                            par[comp1]=comp2;\r\n                            arr[comp2]=arr[comp2]+arr[comp1]+1;\r\n                            arr[comp1]=0;\r\n                        }\r\n                    }\r\n                }\r\n                else{\r\n                    if(comp2==-1)comp2=comp1;\r\n                    else if(comp1==-1)comp1=comp2;\r\n                    row.put(stones[i][0],comp1);\r\n                    col.put(stones[i][1],comp2);\r\n                    if(par[comp1]==-1)arr[comp1]++;\r\n                    else{\r\n                        arr[findParent(comp1)]++;\r\n                    }\r\n                }\r\n            }\r\n            else{\r\n                row.put(stones[i][0],c);\r\n                col.put(stones[i][1],c);\r\n                arr[c]++;\r\n                c++;\r\n            }\r\n        }\r\n        int max=0;\r\n        for(int i=0; i<n; i++){\r\n            if(arr[i]!=0){\r\n                max=max+arr[i]-1;\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n}\r\n"
}