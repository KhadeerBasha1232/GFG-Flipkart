{
  "code": "//Initial Template for Java\r\nimport java.io.*;\r\nimport java.util.*; \r\nclass GFG{\r\n    public static void main(String args[]) throws IOException { \r\n        BufferedReader read = new BufferedReader(new InputStreamReader(System.in));\r\n        int t = Integer.parseInt(read.readLine());\r\n        \r\n        while(t-- > 0){\r\n            int N = Integer.parseInt(read.readLine());\r\n            String input_line[] = read.readLine().trim().split(\"\\\\s+\");\r\n            int A[]= new int[N];\r\n            for(int i = 0; i < N; i++)\r\n                A[i] = Integer.parseInt(input_line[i]);\r\n            input_line = read.readLine().trim().split(\"\\\\s+\");\r\n            int B[]= new int[N];\r\n            for(int i = 0; i < N; i++)\r\n                B[i] = Integer.parseInt(input_line[i]);\r\n        \r\n            Solution ob = new Solution();\r\n            int ans = ob.minSwaps(N, A, B); \r\n            System.out.println(ans);\r\n        }\r\n    } \r\n} \r\n\r\n// } Driver Code Ends\r\n//User function Template for Java\r\nclass Solution \r\n{ \r\n    \r\n    \r\n    int solveRecc(int index, int swapped, int[] A, int[] B, int N){\r\n        if(index==N){\r\n            return 0;\r\n        }\r\n        \r\n        int prevA = index==0?-1:A[index-1];\r\n        int prevB = index==0?-1:B[index-1];\r\n        \r\n        if(swapped==1){\r\n            int temp = prevA;\r\n            prevA = prevB;\r\n            prevB = temp;\r\n        }\r\n        \r\n        int mini = Integer.MAX_VALUE;\r\n        \r\n        // if((A[index]<prevA ||B[index]<prevB) && (A[index]<prevB ||B[index]<prevA)){\r\n        //     return Integer.MAX_VALUE;\r\n        // }\r\n        \r\n        //Swap\r\n        if(A[index]>prevB && B[index]>prevA){\r\n            int ans1 = solveRecc(index+1,1,A,B,N);\r\n            if(ans1!=Integer.MAX_VALUE){\r\n                mini = Math.min(mini, 1+ans1);\r\n            }\r\n            \r\n        }\r\n        \r\n        //No Swap\r\n        if(A[index]>prevA && B[index]>prevB){\r\n            mini = Math.min(mini,solveRecc(index+1,0,A,B,N));\r\n        }\r\n        \r\n        return mini;\r\n        \r\n    }\r\n    \r\n    \r\n    int solveTab(int N, int A[], int B[]){\r\n        \r\n        int[][] dp = new int[N+1][2];\r\n        \r\n        for(int index=N-1;index>=0;index--){\r\n            for(int swapped=0;swapped<=1;swapped++){\r\n                \r\n                int prevA = index==0?-1:A[index-1];\r\n                int prevB = index==0?-1:B[index-1];\r\n                \r\n                if(swapped==1){\r\n                    int temp = prevA;\r\n                    prevA = prevB;\r\n                    prevB = temp;\r\n                }\r\n                \r\n                int mini = Integer.MAX_VALUE;\r\n                \r\n                \r\n                //Swap\r\n                if(A[index]>prevB && B[index]>prevA){\r\n                    int ans1 = dp[index+1][1];\r\n                    if(ans1!=Integer.MAX_VALUE){\r\n                        mini = Math.min(mini, 1+ans1);\r\n                    }\r\n                }\r\n                \r\n                //No Swap\r\n                if(A[index]>prevA && B[index]>prevB){\r\n                    mini = Math.min(mini,dp[index+1][0]);\r\n                }\r\n                \r\n                dp[index][swapped] =  mini;\r\n            }\r\n        }\r\n        \r\n        return dp[0][0];\r\n    }\r\n    \r\n    \r\n    int solveTabOpt(int N, int A[], int B[]){\r\n        \r\n        int[][] dp = new int[N+1][2];\r\n        \r\n        // for(int i=0;i<N;i++){\r\n        //     Arrays.fill(dp[i],Integer.MAX_VALUE);\r\n        // }\r\n        \r\n        A = Arrays.copyOf(A,N+2);\r\n        B = Arrays.copyOf(B,N+2);\r\n        \r\n        for(int i=N-1;i>=0;i--){\r\n            A[i+1] = A[i];\r\n        }\r\n        \r\n        for(int i=N-1;i>=0;i--){\r\n            B[i+1] = B[i];\r\n        }\r\n        \r\n        A[0] = -1;\r\n        B[0] = -1;\r\n        \r\n        for(int i=1;i<=N;i++){\r\n            \r\n            int sw = (int)1e8;\r\n            int ns = (int)1e8;\r\n            \r\n            if(A[i]>B[i-1] && B[i]>A[i-1]){\r\n                sw = Math.min(sw,1 + dp[i-1][0]);\r\n            }\r\n            \r\n            if(A[i]>A[i-1] && B[i]>B[i-1]){\r\n                sw = Math.min(sw,1 + dp[i-1][1]);\r\n            }\r\n            \r\n            if(A[i]>B[i-1] && B[i]>A[i-1]){\r\n                ns = Math.min(ns,dp[i-1][1]);\r\n            }\r\n            \r\n            if(A[i]>A[i-1] && B[i]>B[i-1]){\r\n                ns = Math.min(ns,dp[i-1][0]);\r\n            }\r\n            \r\n            if(Math.min(sw,ns)==(int)1e8){\r\n                return -1;\r\n            }\r\n            \r\n            dp[i][0] = ns;\r\n            dp[i][1] = sw;\r\n            \r\n        }\r\n        \r\n        return Math.min(dp[N][0],dp[N][1]);\r\n        \r\n        \r\n    }\r\n    \r\n    int minSwaps(int N, int A[], int B[]) \r\n    { \r\n        // code here\r\n        // int ans = solveRecc(0,0,A,B,N);\r\n        // return ans==Integer.MAX_VALUE?-1:ans;\r\n        \r\n        \r\n        // int ans = solveTab(N,A,B);\r\n        // return ans==Integer.MAX_VALUE?-1:ans;\r\n        \r\n        return solveTabOpt(N,A,B);\r\n        \r\n        \r\n    }\r\n} \r\n\r\n//{ Driver Code Starts.\r\n\r\n// } Driver Code Ends",
  "status": "1",
  "language": "java",
  "user_code": "//User function Template for Java\r\nclass Solution \r\n{ \r\n    \r\n    \r\n    int solveRecc(int index, int swapped, int[] A, int[] B, int N){\r\n        if(index==N){\r\n            return 0;\r\n        }\r\n        \r\n        int prevA = index==0?-1:A[index-1];\r\n        int prevB = index==0?-1:B[index-1];\r\n        \r\n        if(swapped==1){\r\n            int temp = prevA;\r\n            prevA = prevB;\r\n            prevB = temp;\r\n        }\r\n        \r\n        int mini = Integer.MAX_VALUE;\r\n        \r\n        // if((A[index]<prevA ||B[index]<prevB) && (A[index]<prevB ||B[index]<prevA)){\r\n        //     return Integer.MAX_VALUE;\r\n        // }\r\n        \r\n        //Swap\r\n        if(A[index]>prevB && B[index]>prevA){\r\n            int ans1 = solveRecc(index+1,1,A,B,N);\r\n            if(ans1!=Integer.MAX_VALUE){\r\n                mini = Math.min(mini, 1+ans1);\r\n            }\r\n            \r\n        }\r\n        \r\n        //No Swap\r\n        if(A[index]>prevA && B[index]>prevB){\r\n            mini = Math.min(mini,solveRecc(index+1,0,A,B,N));\r\n        }\r\n        \r\n        return mini;\r\n        \r\n    }\r\n    \r\n    \r\n    int solveTab(int N, int A[], int B[]){\r\n        \r\n        int[][] dp = new int[N+1][2];\r\n        \r\n        for(int index=N-1;index>=0;index--){\r\n            for(int swapped=0;swapped<=1;swapped++){\r\n                \r\n                int prevA = index==0?-1:A[index-1];\r\n                int prevB = index==0?-1:B[index-1];\r\n                \r\n                if(swapped==1){\r\n                    int temp = prevA;\r\n                    prevA = prevB;\r\n                    prevB = temp;\r\n                }\r\n                \r\n                int mini = Integer.MAX_VALUE;\r\n                \r\n                \r\n                //Swap\r\n                if(A[index]>prevB && B[index]>prevA){\r\n                    int ans1 = dp[index+1][1];\r\n                    if(ans1!=Integer.MAX_VALUE){\r\n                        mini = Math.min(mini, 1+ans1);\r\n                    }\r\n                }\r\n                \r\n                //No Swap\r\n                if(A[index]>prevA && B[index]>prevB){\r\n                    mini = Math.min(mini,dp[index+1][0]);\r\n                }\r\n                \r\n                dp[index][swapped] =  mini;\r\n            }\r\n        }\r\n        \r\n        return dp[0][0];\r\n    }\r\n    \r\n    \r\n    int solveTabOpt(int N, int A[], int B[]){\r\n        \r\n        int[][] dp = new int[N+1][2];\r\n        \r\n        // for(int i=0;i<N;i++){\r\n        //     Arrays.fill(dp[i],Integer.MAX_VALUE);\r\n        // }\r\n        \r\n        A = Arrays.copyOf(A,N+2);\r\n        B = Arrays.copyOf(B,N+2);\r\n        \r\n        for(int i=N-1;i>=0;i--){\r\n            A[i+1] = A[i];\r\n        }\r\n        \r\n        for(int i=N-1;i>=0;i--){\r\n            B[i+1] = B[i];\r\n        }\r\n        \r\n        A[0] = -1;\r\n        B[0] = -1;\r\n        \r\n        for(int i=1;i<=N;i++){\r\n            \r\n            int sw = (int)1e8;\r\n            int ns = (int)1e8;\r\n            \r\n            if(A[i]>B[i-1] && B[i]>A[i-1]){\r\n                sw = Math.min(sw,1 + dp[i-1][0]);\r\n            }\r\n            \r\n            if(A[i]>A[i-1] && B[i]>B[i-1]){\r\n                sw = Math.min(sw,1 + dp[i-1][1]);\r\n            }\r\n            \r\n            if(A[i]>B[i-1] && B[i]>A[i-1]){\r\n                ns = Math.min(ns,dp[i-1][1]);\r\n            }\r\n            \r\n            if(A[i]>A[i-1] && B[i]>B[i-1]){\r\n                ns = Math.min(ns,dp[i-1][0]);\r\n            }\r\n            \r\n            if(Math.min(sw,ns)==(int)1e8){\r\n                return -1;\r\n            }\r\n            \r\n            dp[i][0] = ns;\r\n            dp[i][1] = sw;\r\n            \r\n        }\r\n        \r\n        return Math.min(dp[N][0],dp[N][1]);\r\n        \r\n        \r\n    }\r\n    \r\n    int minSwaps(int N, int A[], int B[]) \r\n    { \r\n        // code here\r\n        // int ans = solveRecc(0,0,A,B,N);\r\n        // return ans==Integer.MAX_VALUE?-1:ans;\r\n        \r\n        \r\n        // int ans = solveTab(N,A,B);\r\n        // return ans==Integer.MAX_VALUE?-1:ans;\r\n        \r\n        return solveTabOpt(N,A,B);\r\n        \r\n        \r\n    }\r\n} \r\n"
}