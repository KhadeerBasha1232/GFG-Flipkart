{
  "code": "import java.util.*;\r\nimport java.io.*;\r\nimport java.lang.*;\r\n\r\n\r\nclass GFG\r\n{\r\n    public static void main (String[] args) {\r\n        Scanner sc = new Scanner(System.in);\r\n        int t = sc.nextInt();\r\n        \r\n        int n;\r\n        while(t-- > 0){\r\n            n = sc.nextInt();\r\n    \r\n            Solution obj = new Solution();\r\n            for(int i = 1; i <= n; i++)\r\n            {\r\n                int x =sc.nextInt();\r\n                obj.insertHeap(x);\r\n                System.out.println((int)Math.floor(obj.getMedian()));\r\n            }\r\n        }\r\n        \r\n        \r\n    }\r\n}\r\n\r\n\r\n// } Driver Code Ends\r\n\r\nclass Solution {\r\n    // Max heap to store the smaller half of the numbers\r\n    PriorityQueue<Integer> maxHeap;\r\n    // Min heap to store the larger half of the numbers\r\n    PriorityQueue<Integer> minHeap;\r\n\r\n    // Constructor to initialize the heaps\r\n    public Solution() {\r\n        maxHeap = new PriorityQueue<>(Collections.reverseOrder());\r\n        minHeap = new PriorityQueue<>();\r\n    }\r\n\r\n    // Function to insert x into the heap and balance the heaps\r\n    public void insertHeap(int x) {\r\n        // If maxHeap is empty or x is less than the maximum element in maxHeap, insert into maxHeap\r\n        if (maxHeap.isEmpty() || x <= maxHeap.peek()) {\r\n            maxHeap.add(x);\r\n        } else {\r\n            minHeap.add(x);\r\n        }\r\n        // Balance the heaps\r\n        balanceHeaps();\r\n    }\r\n\r\n    // Function to balance the heaps\r\n    public void balanceHeaps() {\r\n        // If the size of maxHeap is greater than the size of minHeap by more than 1,\r\n        // move the maximum element from maxHeap to minHeap\r\n        while (maxHeap.size() > minHeap.size() + 1) {\r\n            minHeap.add(maxHeap.poll());\r\n        }\r\n        // If the size of minHeap is greater than the size of maxHeap by more than 1,\r\n        // move the minimum element from minHeap to maxHeap\r\n        while (minHeap.size() > maxHeap.size()) {\r\n            maxHeap.add(minHeap.poll());\r\n        }\r\n    }\r\n\r\n    // Function to return the current median\r\n    public double getMedian() {\r\n        // If the size of maxHeap is equal to the size of minHeap, median is the average of the top elements of both heaps\r\n        if (maxHeap.size() == minHeap.size()) {\r\n            return (maxHeap.peek() + minHeap.peek()) / 2.0;\r\n        } else {\r\n            // Otherwise, median is the top element of the heap with more elements\r\n            return maxHeap.peek();\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        Solution solution = new Solution();\r\n        int[] X = {5, 15, 1, 3};\r\n        for (int x : X) {\r\n            solution.insertHeap(x);\r\n            System.out.println(solution.getMedian());\r\n        }\r\n    }\r\n}\r\n",
  "status": "1",
  "language": "java",
  "user_code": "\r\nclass Solution {\r\n    // Max heap to store the smaller half of the numbers\r\n    PriorityQueue<Integer> maxHeap;\r\n    // Min heap to store the larger half of the numbers\r\n    PriorityQueue<Integer> minHeap;\r\n\r\n    // Constructor to initialize the heaps\r\n    public Solution() {\r\n        maxHeap = new PriorityQueue<>(Collections.reverseOrder());\r\n        minHeap = new PriorityQueue<>();\r\n    }\r\n\r\n    // Function to insert x into the heap and balance the heaps\r\n    public void insertHeap(int x) {\r\n        // If maxHeap is empty or x is less than the maximum element in maxHeap, insert into maxHeap\r\n        if (maxHeap.isEmpty() || x <= maxHeap.peek()) {\r\n            maxHeap.add(x);\r\n        } else {\r\n            minHeap.add(x);\r\n        }\r\n        // Balance the heaps\r\n        balanceHeaps();\r\n    }\r\n\r\n    // Function to balance the heaps\r\n    public void balanceHeaps() {\r\n        // If the size of maxHeap is greater than the size of minHeap by more than 1,\r\n        // move the maximum element from maxHeap to minHeap\r\n        while (maxHeap.size() > minHeap.size() + 1) {\r\n            minHeap.add(maxHeap.poll());\r\n        }\r\n        // If the size of minHeap is greater than the size of maxHeap by more than 1,\r\n        // move the minimum element from minHeap to maxHeap\r\n        while (minHeap.size() > maxHeap.size()) {\r\n            maxHeap.add(minHeap.poll());\r\n        }\r\n    }\r\n\r\n    // Function to return the current median\r\n    public double getMedian() {\r\n        // If the size of maxHeap is equal to the size of minHeap, median is the average of the top elements of both heaps\r\n        if (maxHeap.size() == minHeap.size()) {\r\n            return (maxHeap.peek() + minHeap.peek()) / 2.0;\r\n        } else {\r\n            // Otherwise, median is the top element of the heap with more elements\r\n            return maxHeap.peek();\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        Solution solution = new Solution();\r\n        int[] X = {5, 15, 1, 3};\r\n        for (int x : X) {\r\n            solution.insertHeap(x);\r\n            System.out.println(solution.getMedian());\r\n        }\r\n    }\r\n}\r\n"
}