{
  "code": "//Initial Template for C++\r\n\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n// } Driver Code Ends\r\n//User function Template for C++\r\n\r\n//User function Template for C++\r\n\r\n//User function Template for C++\r\n\r\nclass Solution\r\n{\r\npublic:\r\n     bool solve(string pattern, string sample, int currPatternIndex, int startsample, unordered_map<char,string>mp, unordered_set<string>st)\r\n   {\r\n       //Base Condition:\r\n       if(sample.size()==startsample && pattern.size()==currPatternIndex)//both are empty\r\n           return true;\r\n       else  if(sample.size()==startsample || pattern.size()==currPatternIndex)//one of them is empty\r\n           return false;\r\n           \r\n       //Choice Diagram:\r\n       if(mp[pattern[currPatternIndex]]==\"\") //Patten Is found first time so crete pattern \r\n       {\r\n           string temp = \"\";\r\n           for(int i = startsample; i<sample.size(); i++)\r\n           {\r\n               temp+=sample[i];\r\n               //So to allocate diffent sample to diffeernt patterns\r\n               if(st.find(temp)!=st.end()) //if found : means we can not allocate this sample to patter\r\n                   continue;\r\n               //if not found:\r\n               mp[pattern[currPatternIndex]] = temp;\r\n               st.insert(temp);\r\n               if(solve(pattern,sample,currPatternIndex+1,i+1,mp,st))\r\n                   return true;\r\n               //to backtrack we need previous data so restore it    \r\n               st.erase(temp);\r\n               mp[pattern[currPatternIndex]]  = \"\";\r\n           }\r\n           return false;\r\n       }\r\n       else    //Pattern is repeated so just match that previous patter \r\n       {\r\n           string temp = mp[pattern[currPatternIndex]];\r\n           if(sample.size()-startsample<temp.size())\r\n               return false;\r\n           if(temp != sample.substr(startsample,temp.size()))\r\n               return false;\r\n           //pattern match then go next;\r\n           return solve(pattern,sample,currPatternIndex+1,startsample+temp.size(),mp,st);\r\n       }\r\n   }\r\n   int findPattern(string P, string S)\r\n   {\r\n       unordered_map<char,string>mp;\r\n       bool a=1;\r\n       for(int i=0; i<P.size(); i++)\r\n       {\r\n           if(P[i]!='a')\r\n               a=0;\r\n           mp[P[i]] = \"\";\r\n       }    \r\n       if(a)\r\n           return 1;\r\n       unordered_set<string>st;  \r\n       return int(solve(P,S,0,0,mp,st)); \r\n   }\r\n};\r\n\r\n//{ Driver Code Starts.\r\n\r\nint main()\r\n{\r\n    int t;\r\n    cin >> t;\r\n    while (t--) {\r\n        string P, S;\r\n        cin >> P;\r\n        cin >> S;\r\n        Solution ob;\r\n        cout << ob.findPattern(P, S) << \"\\n\";\r\n    }\r\n    return 0;\r\n}\r\n// } Driver Code Ends",
  "status": "1",
  "language": "cpp",
  "user_code": "//User function Template for C++\r\n\r\n//User function Template for C++\r\n\r\n//User function Template for C++\r\n\r\nclass Solution\r\n{\r\npublic:\r\n     bool solve(string pattern, string sample, int currPatternIndex, int startsample, unordered_map<char,string>mp, unordered_set<string>st)\r\n   {\r\n       //Base Condition:\r\n       if(sample.size()==startsample && pattern.size()==currPatternIndex)//both are empty\r\n           return true;\r\n       else  if(sample.size()==startsample || pattern.size()==currPatternIndex)//one of them is empty\r\n           return false;\r\n           \r\n       //Choice Diagram:\r\n       if(mp[pattern[currPatternIndex]]==\"\") //Patten Is found first time so crete pattern \r\n       {\r\n           string temp = \"\";\r\n           for(int i = startsample; i<sample.size(); i++)\r\n           {\r\n               temp+=sample[i];\r\n               //So to allocate diffent sample to diffeernt patterns\r\n               if(st.find(temp)!=st.end()) //if found : means we can not allocate this sample to patter\r\n                   continue;\r\n               //if not found:\r\n               mp[pattern[currPatternIndex]] = temp;\r\n               st.insert(temp);\r\n               if(solve(pattern,sample,currPatternIndex+1,i+1,mp,st))\r\n                   return true;\r\n               //to backtrack we need previous data so restore it    \r\n               st.erase(temp);\r\n               mp[pattern[currPatternIndex]]  = \"\";\r\n           }\r\n           return false;\r\n       }\r\n       else    //Pattern is repeated so just match that previous patter \r\n       {\r\n           string temp = mp[pattern[currPatternIndex]];\r\n           if(sample.size()-startsample<temp.size())\r\n               return false;\r\n           if(temp != sample.substr(startsample,temp.size()))\r\n               return false;\r\n           //pattern match then go next;\r\n           return solve(pattern,sample,currPatternIndex+1,startsample+temp.size(),mp,st);\r\n       }\r\n   }\r\n   int findPattern(string P, string S)\r\n   {\r\n       unordered_map<char,string>mp;\r\n       bool a=1;\r\n       for(int i=0; i<P.size(); i++)\r\n       {\r\n           if(P[i]!='a')\r\n               a=0;\r\n           mp[P[i]] = \"\";\r\n       }    \r\n       if(a)\r\n           return 1;\r\n       unordered_set<string>st;  \r\n       return int(solve(P,S,0,0,mp,st)); \r\n   }\r\n};\r\n"
}