{
  "code": "//Initial Template for Java\n\nimport java.util.LinkedList; \nimport java.util.Queue; \nimport java.io.*;\nimport java.util.*;\n\nclass Node{\n    int data;\n    Node left;\n    Node right;\n    Node(int data){\n        this.data = data;\n        left=null;\n        right=null;\n    }\n}\n\nclass GfG {\n    \n    static Node buildTree(String str){\n        \n        if(str.length()==0 || str.charAt(0)=='N'){\n            return null;\n        }\n        \n        String ip[] = str.split(\" \");\n        // Create the root of the tree\n        Node root = new Node(Integer.parseInt(ip[0]));\n        // Push the root to the queue\n        \n        Queue<Node> queue = new LinkedList<>(); \n        \n        queue.add(root);\n        // Starting from the second element\n        \n        int i = 1;\n        while(queue.size()>0 && i < ip.length) {\n            \n            // Get and remove the front of the queue\n            Node currNode = queue.peek();\n            queue.remove();\n                \n            // Get the current node's value from the string\n            String currVal = ip[i];\n                \n            // If the left child is not null\n            if(!currVal.equals(\"N\")) {\n                    \n                // Create the left child for the current node\n                currNode.left = new Node(Integer.parseInt(currVal));\n                // Push it to the queue\n                queue.add(currNode.left);\n            }\n                \n            // For the right child\n            i++;\n            if(i >= ip.length)\n                break;\n                \n            currVal = ip[i];\n                \n            // If the right child is not null\n            if(!currVal.equals(\"N\")) {\n                    \n                // Create the right child for the current node\n                currNode.right = new Node(Integer.parseInt(currVal));\n                    \n                // Push it to the queue\n                queue.add(currNode.right);\n            }\n            i++;\n        }\n        \n        return root;\n    }\n    \n\tpublic static void main (String[] args) throws IOException{\n\t        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t        \n\t        int t=Integer.parseInt(br.readLine());\n    \n\t        while(t > 0){\n\t            String s = br.readLine();\n    \t    \tNode root = buildTree(s);\n        \t    Solution g = new Solution();\n\t\t\t\n\t\t\t    if(g.isSumTree(root) == true)\n    \t\t\t    System.out.println(1);\n    \t\t\telse \n    \t\t\t    System.out.println(0);\n                t--;\n            \n        }\n    }\n  \n}\n\n\n// } Driver Code Ends\n\n\n/* A Binary Tree node\nclass Node\n{\n    int data;\n    Node left, right;\n\n    Node(int item)\n    {\n        data = item;\n        left = right = null;\n    }\n}\n*/\nclass Solution\n{\n\tboolean isSumTree(Node root)\n\t{\n             // Your code here\n            boolean[] isSum = {true};\n            sum(root, isSum);\n            return isSum[0];\n\t}\n\t\n\tint sum(Node node,boolean[] isSum){\n\t    if(node == null){\n\t        return 0;\n\t    }\n\t    \n\t    if(node.left == null && node.right == null){\n\t        return node.data;\n\t    }\n\t    \n\t    int ls = sum(node.left, isSum);\n\t    int rs = sum(node.right, isSum);\n\t    \n\t    if( ls + rs != node.data){\n\t        isSum[0] = false;\n\t    } \n\t    \n\t    \n\t    return node.data+ls + rs;\n\t}\n\t\n\t\n}\n",
  "status": "1",
  "language": "java",
  "user_code": "\n\n/* A Binary Tree node\nclass Node\n{\n    int data;\n    Node left, right;\n\n    Node(int item)\n    {\n        data = item;\n        left = right = null;\n    }\n}\n*/\nclass Solution\n{\n\tboolean isSumTree(Node root)\n\t{\n             // Your code here\n            boolean[] isSum = {true};\n            sum(root, isSum);\n            return isSum[0];\n\t}\n\t\n\tint sum(Node node,boolean[] isSum){\n\t    if(node == null){\n\t        return 0;\n\t    }\n\t    \n\t    if(node.left == null && node.right == null){\n\t        return node.data;\n\t    }\n\t    \n\t    int ls = sum(node.left, isSum);\n\t    int rs = sum(node.right, isSum);\n\t    \n\t    if( ls + rs != node.data){\n\t        isSum[0] = false;\n\t    } \n\t    \n\t    \n\t    return node.data+ls + rs;\n\t}\n\t\n\t\n}\n"
}