{
  "code": "//Initial Template for Java\r\n\r\nimport java.util.*;\r\nimport java.lang.*;\r\nimport java.io.*;\r\n\r\nclass Robot{\r\n    int direction;\r\n    int x, y, tot;\r\n    final int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\r\n    int grid[][], c[][];\r\n\r\n    public int totalRoomsCleaned(){\r\n        return tot;\r\n    }\r\n\r\n    public Robot(int grid[][], int x, int y){\r\n        direction = 0;\r\n        this.x = x;\r\n        this.y = y;\r\n        tot = 0;\r\n        this.grid = grid;\r\n        c = new int[grid.length][grid[0].length];\r\n    }\r\n\r\n    // Returns true if the cell in front is open and robot moves into the cell.\r\n    // Returns false if the cell in front is blocked and robot stays in the current cell.\r\n    boolean move(){\r\n        int nx = x + dx[direction],\r\n            ny = y + dy[direction];\r\n        if(nx >= 0 && ny >= 0 && nx < grid.length && ny < grid[0].length && grid[nx][ny] == 1){\r\n            x = nx;\r\n            y = ny;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // Robot will stay in the same cell after calling turnLeft/turnRight.\r\n    // Each turn will be 90 degrees.\r\n    void turnLeft(){\r\n        direction += 1;\r\n        if(direction >= 4)\r\n            direction -= 4;\r\n    }\r\n\r\n    void turnRight(){\r\n        direction -= 1;\r\n        if(direction < 0)\r\n            direction += 4;\r\n    }\r\n\r\n    void clean(){\r\n        if(c[x][y] == 0){\r\n            c[x][y] = 1;\r\n            tot++;\r\n        }\r\n    }\r\n}\r\nclass GFG{\r\n    static class FastReader{ \r\n        BufferedReader br; \r\n        StringTokenizer st; \r\n  \r\n        public FastReader(){ \r\n            br = new BufferedReader(new InputStreamReader(System.in)); \r\n        } \r\n  \r\n        String next(){ \r\n            while (st == null || !st.hasMoreElements()){ \r\n                try{ st = new StringTokenizer(br.readLine()); } catch (IOException  e){ e.printStackTrace(); } \r\n            } \r\n            return st.nextToken(); \r\n        } \r\n  \r\n        String nextLine(){ \r\n            String str = \"\"; \r\n            try{ str = br.readLine(); } catch (IOException e) { e.printStackTrace(); } \r\n            return str; \r\n        } \r\n\r\n        Integer nextInt(){\r\n            return Integer.parseInt(next());\r\n        }\r\n\r\n        Long nextLong(){\r\n            return Long.parseLong(next());\r\n        }\r\n    }\r\n\r\n    static void incr(TreeMap<Integer, Integer> mp, int k){\r\n        mp.putIfAbsent(k, 0);\r\n        mp.put(k, mp.get(k) + 1);\r\n    }\r\n\r\n    static int get(TreeMap<Integer, Integer> mp, int k){\r\n        return mp.getOrDefault(k, 0);\r\n    }\r\n\r\n    public static void main(String[] args) throws IOException\r\n    {\r\n        FastReader sc = new FastReader();\r\n        PrintWriter out = new PrintWriter(System.out);\r\n        int t = sc.nextInt();\r\n        while(t-- > 0){\r\n            int N = sc.nextInt(), M = sc.nextInt();\r\n            int grid[][] = new int[N][M];\r\n            for(int i = 0; i < N; i++)\r\n                for(int j = 0; j < M; j++)\r\n                    grid[i][j] = sc.nextInt();\r\n            int row = sc.nextInt(), col = sc.nextInt();\r\n            Solution ob = new Solution();\r\n            Robot r = new Robot(grid, row, col);\r\n            ob.cleanAllRooms(r);\r\n            out.println(r.totalRoomsCleaned());\r\n        }\r\n        out.flush();\r\n    }\r\n}\r\n\r\n\r\n// } Driver Code Ends\r\n\r\n\r\n//User function Template for Java\r\n\r\n/*\r\nclass Robot {\r\n    //returns true if the next cell is valid and not blocked. Otherwise returns false.\r\n    boolean move();\r\n    \r\n    // Robot will stay on the current cell, The cell will turn left by 90 degree.\r\n    void turnLeft();\r\n    \r\n    //Robot will stay on the current cell, The cell will turn right by 90 degree.\r\n    void turnRight();\r\n    \r\n    // Robot cleans the current cell.\r\n    void clean();\r\n}*/\r\n\r\nclass Solution {\r\n    void cleanAllRooms(Robot robot) {\r\n        Set<String> visited = new HashSet<>();\r\n        dfs(robot, 0, 0, 0, visited);\r\n    }\r\n\r\n    void dfs(Robot robot, int row, int col, int direction, Set<String> visited) {\r\n        // Clean the current room\r\n        String roomKey = row + \",\" + col;\r\n        visited.add(roomKey);\r\n        robot.clean();\r\n\r\n        // Explore all possible directions\r\n        for (int i = 0; i < 4; i++) {\r\n            int newDirection = (direction + i) % 4;\r\n            int newRow = row + directions[newDirection][0];\r\n            int newCol = col + directions[newDirection][1];\r\n            String newRoomKey = newRow + \",\" + newCol;\r\n\r\n            // Check if the new room is valid and not visited\r\n            if (!visited.contains(newRoomKey) && robot.move()) {\r\n                dfs(robot, newRow, newCol, newDirection, visited);\r\n\r\n                // Move back to the previous room after cleaning\r\n                robot.turnLeft();\r\n                robot.turnLeft();\r\n                robot.move();\r\n                robot.turnLeft();\r\n                robot.turnLeft();\r\n            }\r\n\r\n            // Turn the robot to the right for the next direction\r\n            robot.turnRight();\r\n        }\r\n    }\r\n\r\n    // Define directions (up, right, down, left)\r\n    int[][] directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\r\n}\r\n",
  "status": "1",
  "language": "java",
  "user_code": "\r\n\r\n//User function Template for Java\r\n\r\n/*\r\nclass Robot {\r\n    //returns true if the next cell is valid and not blocked. Otherwise returns false.\r\n    boolean move();\r\n    \r\n    // Robot will stay on the current cell, The cell will turn left by 90 degree.\r\n    void turnLeft();\r\n    \r\n    //Robot will stay on the current cell, The cell will turn right by 90 degree.\r\n    void turnRight();\r\n    \r\n    // Robot cleans the current cell.\r\n    void clean();\r\n}*/\r\n\r\nclass Solution {\r\n    void cleanAllRooms(Robot robot) {\r\n        Set<String> visited = new HashSet<>();\r\n        dfs(robot, 0, 0, 0, visited);\r\n    }\r\n\r\n    void dfs(Robot robot, int row, int col, int direction, Set<String> visited) {\r\n        // Clean the current room\r\n        String roomKey = row + \",\" + col;\r\n        visited.add(roomKey);\r\n        robot.clean();\r\n\r\n        // Explore all possible directions\r\n        for (int i = 0; i < 4; i++) {\r\n            int newDirection = (direction + i) % 4;\r\n            int newRow = row + directions[newDirection][0];\r\n            int newCol = col + directions[newDirection][1];\r\n            String newRoomKey = newRow + \",\" + newCol;\r\n\r\n            // Check if the new room is valid and not visited\r\n            if (!visited.contains(newRoomKey) && robot.move()) {\r\n                dfs(robot, newRow, newCol, newDirection, visited);\r\n\r\n                // Move back to the previous room after cleaning\r\n                robot.turnLeft();\r\n                robot.turnLeft();\r\n                robot.move();\r\n                robot.turnLeft();\r\n                robot.turnLeft();\r\n            }\r\n\r\n            // Turn the robot to the right for the next direction\r\n            robot.turnRight();\r\n        }\r\n    }\r\n\r\n    // Define directions (up, right, down, left)\r\n    int[][] directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\r\n}\r\n"
}