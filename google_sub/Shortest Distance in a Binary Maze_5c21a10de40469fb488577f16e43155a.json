{
  "code": "// Initial Template for Java\r\n\r\nimport java.util.*;\r\nimport java.lang.*;\r\nimport java.io.*;\r\n\r\n// Position this line where user code will be pasted.\r\n\r\nclass GFG {\r\n    public static void main(String[] args) throws IOException {\r\n        Scanner sc = new Scanner(System.in);\r\n        int T = sc.nextInt();\r\n        while (T-- > 0) {\r\n            int n = sc.nextInt();\r\n            int m = sc.nextInt();\r\n            int[][] grid = new int[n][m];\r\n\r\n            for (int i = 0; i < n; i++) {\r\n\r\n                for (int j = 0; j < m; j++) {\r\n                    grid[i][j] = sc.nextInt();\r\n                }\r\n            }\r\n            int[] source = new int[2];\r\n            for (int i = 0; i < 2; i++) {\r\n                int x = sc.nextInt();\r\n                source[i] = x;\r\n            }\r\n            int[] dest = new int[2];\r\n            for (int i = 0; i < 2; i++) {\r\n                int x = sc.nextInt();\r\n                dest[i] = x;\r\n            }\r\n            Solution ob = new Solution();\r\n            int ans = ob.shortestPath(grid, source, dest);\r\n            System.out.println(ans);\r\n        }\r\n    }\r\n}\r\n// } Driver Code Ends\r\n\r\n\r\n// User function Template for Java\r\n\r\nclass Solution {\r\n    class tuple{\r\n        int first,second,third;\r\n        tuple(int a,int b,int c){\r\n            first =a;\r\n            second = b;\r\n            third = c;\r\n        }\r\n    }\r\n    int shortestPath(int[][] grid, int[] source, int[] destination) {\r\n        int n = grid.length;\r\n        int m = grid[0].length;\r\n        \r\n        if(source[0]==destination[0] && source[1] == destination[1]) return 0;\r\n        \r\n        int dist[][] = new int[n][m];\r\n        for(int a[] : dist){\r\n            Arrays.fill(a,Integer.MAX_VALUE);\r\n        }\r\n        \r\n        dist[source[0]][source[1]] = 0;\r\n        Queue<tuple> q = new ArrayDeque<>();\r\n        q.add(new tuple(0,source[0],source[1]));\r\n        int dx[] = {-1,0,1,0};\r\n        int dy[] = {0,1,0,-1};\r\n        \r\n        while(!q.isEmpty()){\r\n            tuple top = q.poll();\r\n            int dis = top.first;\r\n            int x = top.second;\r\n            int y = top.third;\r\n            \r\n            for(int i=0;i<4;i++){\r\n                int newR = x+dx[i];\r\n                int newC = y+dy[i];\r\n                \r\n                if(newR>=0 && newC>=0 && newR<n && newC<m && grid[newR][newC] == 1 && dis+1 < dist[newR][newC]){\r\n                    dist[newR][newC] = dis+1;\r\n                    if(newR == destination[0] && newC == destination[1]){\r\n                        return dis+1;\r\n                    }\r\n                    q.add(new tuple(dis+1,newR,newC));\r\n                }\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n",
  "status": "1",
  "language": "java",
  "user_code": "\r\n\r\n// User function Template for Java\r\n\r\nclass Solution {\r\n    class tuple{\r\n        int first,second,third;\r\n        tuple(int a,int b,int c){\r\n            first =a;\r\n            second = b;\r\n            third = c;\r\n        }\r\n    }\r\n    int shortestPath(int[][] grid, int[] source, int[] destination) {\r\n        int n = grid.length;\r\n        int m = grid[0].length;\r\n        \r\n        if(source[0]==destination[0] && source[1] == destination[1]) return 0;\r\n        \r\n        int dist[][] = new int[n][m];\r\n        for(int a[] : dist){\r\n            Arrays.fill(a,Integer.MAX_VALUE);\r\n        }\r\n        \r\n        dist[source[0]][source[1]] = 0;\r\n        Queue<tuple> q = new ArrayDeque<>();\r\n        q.add(new tuple(0,source[0],source[1]));\r\n        int dx[] = {-1,0,1,0};\r\n        int dy[] = {0,1,0,-1};\r\n        \r\n        while(!q.isEmpty()){\r\n            tuple top = q.poll();\r\n            int dis = top.first;\r\n            int x = top.second;\r\n            int y = top.third;\r\n            \r\n            for(int i=0;i<4;i++){\r\n                int newR = x+dx[i];\r\n                int newC = y+dy[i];\r\n                \r\n                if(newR>=0 && newC>=0 && newR<n && newC<m && grid[newR][newC] == 1 && dis+1 < dist[newR][newC]){\r\n                    dist[newR][newC] = dis+1;\r\n                    if(newR == destination[0] && newC == destination[1]){\r\n                        return dis+1;\r\n                    }\r\n                    q.add(new tuple(dis+1,newR,newC));\r\n                }\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n"
}