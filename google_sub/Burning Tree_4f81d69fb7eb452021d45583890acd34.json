{
  "code": "//Initial Template for Java\r\n\r\n\r\nimport java.util.LinkedList;\r\nimport java.util.Queue;\r\nimport java.io.*;\r\nimport java.util.*;\r\n\r\nclass Node {\r\n\tint data;\r\n\tNode left;\r\n\tNode right;\r\n\r\n\tNode(int data) {\r\n\t\tthis.data = data;\r\n\t\tleft = null;\r\n\t\tright = null;\r\n\t}\r\n}\r\n\r\nclass GfG {\r\n\r\n\tstatic Node buildTree(String str) {\r\n\r\n\t\tif (str.length() == 0 || str.charAt(0) == 'N') {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tString ip[] = str.split(\" \");\r\n\t\t// Create the root of the tree\r\n\t\tNode root = new Node(Integer.parseInt(ip[0]));\r\n\t\t// Push the root to the queue\r\n\r\n\t\tQueue<Node> queue = new LinkedList<>();\r\n\r\n\t\tqueue.add(root);\r\n\t\t// Starting from the second element\r\n\r\n\t\tint i = 1;\r\n\t\twhile (queue.size() > 0 && i < ip.length) {\r\n\r\n\t\t\t// Get and remove the front of the queue\r\n\t\t\tNode currNode = queue.peek();\r\n\t\t\tqueue.remove();\r\n\r\n\t\t\t// Get the current node's value from the string\r\n\t\t\tString currVal = ip[i];\r\n\r\n\t\t\t// If the left child is not null\r\n\t\t\tif (!currVal.equals(\"N\")) {\r\n\r\n\t\t\t\t// Create the left child for the current node\r\n\t\t\t\tcurrNode.left = new Node(Integer.parseInt(currVal));\r\n\t\t\t\t// Push it to the queue\r\n\t\t\t\tqueue.add(currNode.left);\r\n\t\t\t}\r\n\r\n\t\t\t// For the right child\r\n\t\t\ti++;\r\n\t\t\tif (i >= ip.length)\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcurrVal = ip[i];\r\n\r\n\t\t\t// If the right child is not null\r\n\t\t\tif (!currVal.equals(\"N\")) {\r\n\r\n\t\t\t\t// Create the right child for the current node\r\n\t\t\t\tcurrNode.right = new Node(Integer.parseInt(currVal));\r\n\r\n\t\t\t\t// Push it to the queue\r\n\t\t\t\tqueue.add(currNode.right);\r\n\t\t\t}\r\n\t\t\ti++;\r\n\t\t}\r\n\r\n\t\treturn root;\r\n\t}\r\n\r\n\tstatic void printInorder(Node root) {\r\n\t\tif (root == null)\r\n\t\t\treturn;\r\n\r\n\t\tprintInorder(root.left);\r\n\t\tSystem.out.print(root.data + \" \");\r\n\r\n\t\tprintInorder(root.right);\r\n\t}\r\n\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\r\n\t\tint t = Integer.parseInt(br.readLine());\r\n\r\n\t\twhile (t > 0) {\r\n\t\t\tString s = br.readLine();\r\n\t\t\tint target = Integer.parseInt(br.readLine());\r\n\t\t\tNode root = buildTree(s);\r\n\r\n\t\t\tSolution g = new Solution();\r\n\t\t\tSystem.out.println(g.minTime(root, target));\r\n\t\t\tt--;\r\n\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n\r\n// } Driver Code Ends\r\n\r\n\r\n//User function Template for Java\r\n\r\nclass Solution\r\n{\r\n    /*class Node {\r\n    \tint data;\r\n    \tNode left;\r\n    \tNode right;\r\n    \r\n    \tNode(int data) {\r\n    \t\tthis.data = data;\r\n    \t\tleft = null;\r\n    \t\tright = null;\r\n    \t}\r\n    }*/\r\n    static Map<Integer, Node> parent;\r\n    static Node targetNode;\r\n    public static void dfs(Node root, Node par, int target) {\r\n        if(root == null){\r\n            return;\r\n        }\r\n        if(root.data == target) {\r\n            targetNode = root;\r\n        }\r\n        parent.put(root.data, par);\r\n        dfs(root.left, root, target);\r\n        dfs(root.right, root, target);\r\n    }\r\n    \r\n    public static int minTime(Node root, int target) \r\n    {\r\n        // Your code goes here\r\n        parent = new HashMap<>();\r\n        ArrayDeque<Node> queue = new ArrayDeque<>();\r\n        Set<Integer> vis = new HashSet<>();\r\n        dfs(root, null, target);\r\n        if(targetNode != null)\r\n        queue.add(targetNode);\r\n        vis.add(targetNode.data);\r\n        int cnt = 0;\r\n        // parent.forEach((k, v) -> {\r\n        //      System.out.print(\"node: \" + k);\r\n        //      if(v != null) {\r\n        //          System.out.println(\" :\" + v.data);\r\n        //      } else {\r\n        //                  System.out.println();\r\n        //      }\r\n        // });\r\n        // System.out.println(targetNode.data);\r\n        while(!queue.isEmpty()) {\r\n          int n = queue.size();\r\n        //   System.out.println(\"n: \" + n);\r\n          for(int i = 0; i < n; i++) {\r\n            Node node = queue.poll();\r\n            if(node.left != null && !vis.contains(node.left.data)) {\r\n                queue.add(node.left);\r\n                vis.add(node.left.data);\r\n            }\r\n            if(node.right != null && !vis.contains(node.right.data)) {\r\n                queue.add(node.right);\r\n                vis.add(node.right.data);\r\n            }\r\n            Node p = parent.get(node.data);\r\n            if(p != null){\r\n            // System.out.println(\"node: \" + p.data);\r\n            }\r\n            if( p!= null && !vis.contains(p.data)) {\r\n                queue.add(p);\r\n                vis.add(p.data);\r\n            }\r\n          }\r\n          cnt++;\r\n        }\r\n        return cnt - 1;\r\n    }\r\n}",
  "status": "1",
  "language": "java",
  "user_code": "\r\n\r\n//User function Template for Java\r\n\r\nclass Solution\r\n{\r\n    /*class Node {\r\n    \tint data;\r\n    \tNode left;\r\n    \tNode right;\r\n    \r\n    \tNode(int data) {\r\n    \t\tthis.data = data;\r\n    \t\tleft = null;\r\n    \t\tright = null;\r\n    \t}\r\n    }*/\r\n    static Map<Integer, Node> parent;\r\n    static Node targetNode;\r\n    public static void dfs(Node root, Node par, int target) {\r\n        if(root == null){\r\n            return;\r\n        }\r\n        if(root.data == target) {\r\n            targetNode = root;\r\n        }\r\n        parent.put(root.data, par);\r\n        dfs(root.left, root, target);\r\n        dfs(root.right, root, target);\r\n    }\r\n    \r\n    public static int minTime(Node root, int target) \r\n    {\r\n        // Your code goes here\r\n        parent = new HashMap<>();\r\n        ArrayDeque<Node> queue = new ArrayDeque<>();\r\n        Set<Integer> vis = new HashSet<>();\r\n        dfs(root, null, target);\r\n        if(targetNode != null)\r\n        queue.add(targetNode);\r\n        vis.add(targetNode.data);\r\n        int cnt = 0;\r\n        // parent.forEach((k, v) -> {\r\n        //      System.out.print(\"node: \" + k);\r\n        //      if(v != null) {\r\n        //          System.out.println(\" :\" + v.data);\r\n        //      } else {\r\n        //                  System.out.println();\r\n        //      }\r\n        // });\r\n        // System.out.println(targetNode.data);\r\n        while(!queue.isEmpty()) {\r\n          int n = queue.size();\r\n        //   System.out.println(\"n: \" + n);\r\n          for(int i = 0; i < n; i++) {\r\n            Node node = queue.poll();\r\n            if(node.left != null && !vis.contains(node.left.data)) {\r\n                queue.add(node.left);\r\n                vis.add(node.left.data);\r\n            }\r\n            if(node.right != null && !vis.contains(node.right.data)) {\r\n                queue.add(node.right);\r\n                vis.add(node.right.data);\r\n            }\r\n            Node p = parent.get(node.data);\r\n            if(p != null){\r\n            // System.out.println(\"node: \" + p.data);\r\n            }\r\n            if( p!= null && !vis.contains(p.data)) {\r\n                queue.add(p);\r\n                vis.add(p.data);\r\n            }\r\n          }\r\n          cnt++;\r\n        }\r\n        return cnt - 1;\r\n    }\r\n}"
}