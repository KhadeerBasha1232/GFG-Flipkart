{
  "code": "from collections import defaultdict\r\nclass Solution:\r\n    def findSequences(self, beginWord, endWord, wordList):\r\n        #Code here\r\n        # Convert wordList to a set for faster lookup\r\n        wordSet = set(wordList)\r\n        \r\n        # Initialize the queue with the starting sequence\r\n        queue = deque([[beginWord]])\r\n        \r\n        # Keep track of words used on the current level\r\n        usedOnLevel = set([beginWord])\r\n        \r\n        # Initialize the current level\r\n        level = 0\r\n        \r\n        # Initialize the result list\r\n        result = []\r\n        \r\n        while queue:\r\n            # Get the sequence from the front of the queue\r\n            sequence = queue.popleft()\r\n            \r\n            # Check if the length of the current sequence is greater than the current level\r\n            if len(sequence) > level:\r\n                level += 1\r\n                \r\n                # Remove words used on the previous level from the wordSet\r\n                for word in usedOnLevel:\r\n                    if word in wordSet:\r\n                        wordSet.remove(word)\r\n            \r\n            # Get the last word in the sequence\r\n            lastWord = sequence[-1]\r\n            \r\n            # Check if the last word is the endWord\r\n            if lastWord == endWord:\r\n                # Check if this is the first sequence of this length\r\n                if len(result) == 0:\r\n                    result.append(sequence)\r\n                # Check if subsequent sequences have the same length\r\n                elif len(result[0]) == len(sequence):\r\n                    result.append(sequence)\r\n                else:\r\n                    # Break if sequences of different lengths are encountered\r\n                    break\r\n            \r\n            # Explore all possible transformations of the last word\r\n            for i in range(len(lastWord)):\r\n                originalChar = lastWord[i]\r\n                \r\n                # Try changing each character to all lowercase alphabets\r\n                for ch in range(ord('a'), ord('z') + 1):\r\n                    lastWord = lastWord[:i] + chr(ch) + lastWord[i+1:]\r\n                    \r\n                    # If the new word is in the wordSet, add it to the queue\r\n                    if lastWord in wordSet:\r\n                        newSequence = list(sequence)\r\n                        newSequence.append(lastWord)\r\n                        queue.append(newSequence)\r\n                        usedOnLevel.add(lastWord)\r\n                \r\n                # Revert the change to the original character\r\n                lastWord = lastWord[:i] + originalChar + lastWord[i+1:]\r\n\r\n        return result\r\n\r\n#{ \r\n # Driver Code Starts\r\n\r\nfrom collections import deque \r\nimport functools\r\n\r\ndef comp(a, b):\r\n    x = \"\"\r\n    y = \"\"\r\n    for i in a:\r\n        x += i \r\n    for i in b:\r\n        y += i\r\n    if x>y:\r\n        return 1\r\n    elif y>x:\r\n        return -1 \r\n    else:\r\n        return 0\r\n\r\nif __name__ == '__main__':\r\n    T=int(input())\r\n    for tt in range(T):\r\n        n = int(input())\r\n        wordList = []\r\n        for i in range(n):\r\n            wordList.append(input().strip())\r\n        startWord = input().strip()\r\n        targetWord = input().strip()\r\n        obj = Solution()\r\n        ans = obj.findSequences(startWord, targetWord, wordList)\r\n        if len(ans)==0:\r\n            print(-1)\r\n        else:\r\n            ans = sorted(ans, key=functools.cmp_to_key(comp))\r\n            for i in range(len(ans)):\r\n                for j in range(len(ans[i])):\r\n                    print(ans[i][j],end=\" \")\r\n                print()\r\n\r\n# } Driver Code Ends",
  "status": "1",
  "language": "python3",
  "user_code": "#User function Template for python3\r\nfrom collections import defaultdict\r\nclass Solution:\r\n    def findSequences(self, beginWord, endWord, wordList):\r\n        #Code here\r\n        # Convert wordList to a set for faster lookup\r\n        wordSet = set(wordList)\r\n        \r\n        # Initialize the queue with the starting sequence\r\n        queue = deque([[beginWord]])\r\n        \r\n        # Keep track of words used on the current level\r\n        usedOnLevel = set([beginWord])\r\n        \r\n        # Initialize the current level\r\n        level = 0\r\n        \r\n        # Initialize the result list\r\n        result = []\r\n        \r\n        while queue:\r\n            # Get the sequence from the front of the queue\r\n            sequence = queue.popleft()\r\n            \r\n            # Check if the length of the current sequence is greater than the current level\r\n            if len(sequence) > level:\r\n                level += 1\r\n                \r\n                # Remove words used on the previous level from the wordSet\r\n                for word in usedOnLevel:\r\n                    if word in wordSet:\r\n                        wordSet.remove(word)\r\n            \r\n            # Get the last word in the sequence\r\n            lastWord = sequence[-1]\r\n            \r\n            # Check if the last word is the endWord\r\n            if lastWord == endWord:\r\n                # Check if this is the first sequence of this length\r\n                if len(result) == 0:\r\n                    result.append(sequence)\r\n                # Check if subsequent sequences have the same length\r\n                elif len(result[0]) == len(sequence):\r\n                    result.append(sequence)\r\n                else:\r\n                    # Break if sequences of different lengths are encountered\r\n                    break\r\n            \r\n            # Explore all possible transformations of the last word\r\n            for i in range(len(lastWord)):\r\n                originalChar = lastWord[i]\r\n                \r\n                # Try changing each character to all lowercase alphabets\r\n                for ch in range(ord('a'), ord('z') + 1):\r\n                    lastWord = lastWord[:i] + chr(ch) + lastWord[i+1:]\r\n                    \r\n                    # If the new word is in the wordSet, add it to the queue\r\n                    if lastWord in wordSet:\r\n                        newSequence = list(sequence)\r\n                        newSequence.append(lastWord)\r\n                        queue.append(newSequence)\r\n                        usedOnLevel.add(lastWord)\r\n                \r\n                # Revert the change to the original character\r\n                lastWord = lastWord[:i] + originalChar + lastWord[i+1:]\r\n\r\n        return result\r\n\r\n"
}